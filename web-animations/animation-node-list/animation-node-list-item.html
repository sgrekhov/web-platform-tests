<!DOCTYPE html>
<meta charset=utf-8>
<title>AnimationNodeList item[index] test</title>
<meta name="assert" content="Returns the animation node at index. If index is greater than or equal to length returns null.">
<link rel="help" href="http://w3c.github.io/web-animations/#dom-animationnodelist-item">
<link rel="author" title="Sergey G. Grekhov" href="mailto:sgrekhov@unipro.ru">
<link rel="author" title="Aleksei Yu. Semenov" href="mailto:a.semenov@unipro.ru">
<script src="/resources/testharness.js"></script>
<script src="/resources/testharnessreport.js"></script>
<script src="../testcommon.js"></script>
<link rel="stylesheet" href="/resources/testharness.css">
<body>
<div id="log"></div>
<script>
test(function() {
    var nodes = [new AnimationGroup([]), new AnimationSequence([])];
    nodes.forEach(function(node) {
        assert_equals(node.children[0], null, 'AnimationNodeList.item[index] should return ' +
            'null if index equals the number of animation nodes in the list');
        assert_equals(node.children[1], null, 'AnimationNodeList.item[index] should return ' +
            'null if index is greater than the number of animation nodes in the list');
    });
}, 'AnimationNodeList.item[index] returns null if index greater or equals the number of ' +
    'animation nodes in the list. Test empty AnimationNodeList');

test(function() {
    var nodes = [
        new Animation(createDiv(this), KEYFRAMES, ANIMATION_DURATION),
        new Animation(createDiv(this), KEYFRAMES, ANIMATION_DURATION)
    ];
    var parents = [new AnimationGroup([nodes[0]]), new AnimationSequence([nodes[1]])];

    parents.forEach(function(parent, index) {
        assert_equals(parent.children[0], nodes[index], 'AnimationNodeList.item[index] should return ' +
            'node at index in the list');
        assert_equals(parent.children[1], null, 'AnimationNodeList.item[index] should return ' +
            'null if index equals the number of animation nodes in the list');
        assert_equals(parent.children[2], null, 'AnimationNodeList.item[index] should return ' +
            'null if index is greater than the number of animation nodes in the list');
    });
}, 'AnimationNodeList.item[index] returns null if index greater or equals the number of ' +
    'animation nodes in the list. Test non empty AnimationNodeList');

test(function() {
    var test = this;
    var parentCtors = [AnimationGroup, AnimationSequence];
    parentCtors.forEach(function(parentCtor) {
        var node1 = new Animation(createDiv(test), KEYFRAMES, ANIMATION_DURATION);
        var node2 = new AnimationGroup([]);
        var node3 = new AnimationSequence([]);
        var parent = new parentCtor([node1, node2, node3]);

        assert_equals(parent.children[0], node1, 'AnimationNodeList.item[0] should return ' +
            'node at 0 in the list');
        assert_equals(parent.children[1], node2, 'AnimationNodeList.item[1] should return ' +
            'node at 1 in the list');
        assert_equals(parent.children[2], node3, 'AnimationNodeList.item[2] should return ' +
            'node at 2 in the list');
    });
}, 'Test AnimationNodeList.item[index] returns node at index in the list');

test(function() {
    var test = this;
    var nodes = [new AnimationGroup([]), new AnimationSequence([])];
    nodes.forEach(function(node1) {
        var node2 = new Animation(createDiv(test), KEYFRAMES, ANIMATION_DURATION);
        node1.append(node2);
        assert_equals(node1.children[0], node2, type(node1) + '.children[0] ' +
            'should be updated');
    });
}, 'Test AnimationNodeList.item[index] returns node at index in the list, ' +
    'the list is changed by method AnimationGroup.append()');

test(function() {
    var test = this;
    var nodes = [new AnimationGroup([]), new AnimationSequence([])];
    nodes.forEach(function(node1) {
        var node2 = new Animation(createDiv(test), KEYFRAMES, ANIMATION_DURATION);
        node1.prepend(node2);
        assert_equals(node1.children[0], node2, type(node1) + '.children[0] ' +
            'should be updated');
    });
}, 'Test AnimationNodeList.item[index] returns node at index in the list, ' +
    'the list is changed by method AnimationGroup.prepend()');

test(function() {
    var test = this;
    var nodes = [
        new Animation(createDiv(this), KEYFRAMES, ANIMATION_DURATION),
        new Animation(createDiv(this), KEYFRAMES, ANIMATION_DURATION)
    ];
    var parents = [new AnimationGroup([nodes[0]]), new AnimationSequence([nodes[1]])];

    nodes.forEach(function(node1, index) {
        var node2 = new Animation(createDiv(test), KEYFRAMES, ANIMATION_DURATION);
        node1.before(node2);
        assert_equals(parents[index].children[0], node2, type(parents[index]) +
            '.children[0] should be updated');
        assert_equals(parents[index].children[1], node1, type(parents[index]) +
            '.children[1] should be updated');
    });
}, 'Test AnimationNodeList.item[index] returns node at index in the list, ' +
    'the list is changed by method AnimationNode.before()');

test(function() {
    var test = this;
    var nodes = [
        new Animation(createDiv(this), KEYFRAMES, ANIMATION_DURATION),
        new Animation(createDiv(this), KEYFRAMES, ANIMATION_DURATION)
    ];
    var parents = [new AnimationGroup([nodes[0]]), new AnimationSequence([nodes[1]])];

    nodes.forEach(function(node1, index) {
        var node2 = new Animation(createDiv(test), KEYFRAMES, ANIMATION_DURATION);
        node1.after(node2);
        assert_equals(parents[index].children[0], node1, type(parents[index]) +
            '.children[0] should be updated');
        assert_equals(parents[index].children[1], node2, type(parents[index]) +
            '.children[1] should be updated');
    });
}, 'Test AnimationNodeList.item[index] returns node at index in the list, ' +
    'the list is changed by method AnimationNode.after()');

test(function() {
    var test = this;
    var nodes = [
        new Animation(createDiv(this), KEYFRAMES, ANIMATION_DURATION),
        new Animation(createDiv(this), KEYFRAMES, ANIMATION_DURATION)
    ];
    var parents = [new AnimationGroup([nodes[0]]), new AnimationSequence([nodes[1]])];

    nodes.forEach(function(node1, index) {
        var node2 = new Animation(createDiv(test), KEYFRAMES, ANIMATION_DURATION);
        var node3 = new Animation(createDiv(test), KEYFRAMES, ANIMATION_DURATION);
        node1.replace(node2, node3);
        assert_equals(parents[index].children[0], node2, type(parents[index]) +
            '.children[0] should be updated');
        assert_equals(parents[index].children[1], node3, type(parents[index]) +
            '.children[1] should be updated');
    });
}, 'Test AnimationNodeList.item[index] returns node at index in the list, ' +
    'the list is changed by method AnimationNode.replace()');

test(function() {
    var nodes = [
        new Animation(createDiv(this), KEYFRAMES, ANIMATION_DURATION),
        new Animation(createDiv(this), KEYFRAMES, ANIMATION_DURATION)
    ];
    var parents = [new AnimationGroup([nodes[0]]), new AnimationSequence([nodes[1]])];

    nodes.forEach(function(node, index) {
        node.remove();
        assert_equals(parents[index].children[0], null, type(parents[index]) +
            '.children[0] should be updated');
    });
}, 'Test AnimationNodeList.item[index] returns node at index in the list, ' +
    'the list is changed by method AnimationNode.remove()');
</script>
</body>
