<!DOCTYPE html>
<meta charset=utf-8>
<title>AnimationEffect iterationComposite attribute tests</title>
<meta name="assert" content="The iteration composite operation property of this animation effect as specified by one of the IterationCompositeOperation enumeration values">
<link rel="help" href="http://w3c.github.io/web-animations/#dom-animationeffect-iterationcomposite">
<link rel="help" href="http://w3c.github.io/web-animations/#iteration-composite-operation">
<link rel="author" title="Sergey G. Grekhov" href="mailto:sgrekhov@unipro.ru">
<link rel="author" title="Aleksei Yu. Semenov" href="mailto:a.semenov@unipro.ru">
<script src="/resources/testharness.js"></script>
<script src="/resources/testharnessreport.js"></script>
<script src="../testcommon.js"></script>
<link rel="stylesheet" href="/resources/testharness.css">
<body>
<div id="log"></div>
<script>
var TIMEOUT = ANIMATION_DURATION / 10;

test(function() {
    var effect = newKeyframeEffect();

    assert_equals(effect.iterationComposite, 'replace', 'Wrong default value of ' +
        'iterationComposite attribute of effect ' + type(effect));
}, 'Test AnimationEffect.iterationComposite default value is \'replace\'');

test(function() {
    var effect = newKeyframeEffect({iterationComposite: 'accumulate'});

    assert_equals(effect.iterationComposite, 'accumulate', type(effect) +
        '.iterationComposite should return the value specified in constructor arguments');
}, 'Test AnimationEffect.iterationComposite attribute returns value set by constructor');

async_test(function(t) {
    var effect = newKeyframeEffect({iterationComposite: 'accumulate'});

    var target = createDiv(t);
    var animation = new Animation(target, effect,
        {iterations: 3, duration: ANIMATION_DURATION});
    var player = document.timeline.play(animation);
    player.currentTime = ANIMATION_DURATION - 10;

    player.ready.then(t.step_func(function() {
        setTimeout(t.step_func(function() {
            // After the first iteration target element top == 200px
            // After TIMEOUT ms of the second iteration top should be
            // 200 + 'top at TIMEOUT ms'
            assert_approx_equals(window.getComputedStyle(target).top,
                ANIMATION_TOP_1 + getExpectedTop(TIMEOUT), 10,
                'Animated attribute \'top\' value should be accumulated ' +
                'with the final value of the previous iteration');
            t.done();
        }), TIMEOUT + 10);
    }), t.unreached_func('Current ready promise should not be rejected'));
}, 'Test AnimationEffect.iterationComposite value \'accumulate\' forces animated value ' +
    'to accumulate with the final value of the previous iteration');

async_test(function(t) {
    var effect = newKeyframeEffect({iterationComposite: 'repace'});
    var target = createDiv(t);
    var animation = new Animation(target, effect,
        {iterations: 3, duration: ANIMATION_DURATION});
    var player = document.timeline.play(animation);
    player.currentTime = ANIMATION_DURATION - 10;

    player.ready.then(t.step_func(function() {
        setTimeout(t.step_func(function() {
            assert_approx_equals(window.getComputedStyle(target).top,
                getExpectedTop(TIMEOUT), COMPUTED_STYLE_EPSILON,
                'Animated attribute \'top\' value should replace ' +
                'the final value of the previous iteration');
            t.done();
        }), TIMEOUT + 10);
    }), t.unreached_func('Current ready promise should not be rejected'));
}, 'Test AnimationEffect.iterationComposite value \'repace\' forces animated value ' +
    'to be produced independent of the current iteration');

async_test(function(t) {
    var effect = newKeyframeEffect();
    effect.iterationComposite = 'accumulate';
    var target = createDiv(t);
    var animation = new Animation(target, effect,
        {iterations: 3, duration: ANIMATION_DURATION});
    var player = document.timeline.play(animation);
    player.currentTime = ANIMATION_DURATION - 10;

    player.ready.then(t.step_func(function() {
        setTimeout(t.step_func(function() {
            // After the first iteration target element top == 200px
            // After TIMEOUT ms of the second iteration width should be
            // 200 + 'width at TIMEOUT ms'
            assert_approx_equals(window.getComputedStyle(target).top,
                ANIMATION_TOP_1 + getExpectedTop(TIMEOUT), COMPUTED_STYLE_EPSILON,
                'Animated attribute \'top\' value should be accumulated ' +
                'with the final value of the previous iteration');

            // Now seek to the end, change iteration composition
            // to 'replace' and check
            player.currentTime = 2 * ANIMATION_DURATION - 10;
            effect.iterationComposite = 'replace';
            setTimeout(t.step_func(function() {
                assert_approx_equals(window.getComputedStyle(target).top,
                    getExpectedTop(TIMEOUT), COMPUTED_STYLE_EPSILON,
                    'Animated attribute \'top\' value should replace ' +
                    'the final value of the previous iteration');
                t.done();
            }), TIMEOUT + 10);
        }), TIMEOUT + 10);
    }), t.unreached_func('Current ready promise should not be rejected'));
}, 'Test AnimationEffect.iterationComposite controls how values are combined ' +
    'between successive iterations of the same animation');
</script>
</body>
