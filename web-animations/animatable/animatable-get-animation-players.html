<!DOCTYPE html>
<meta charset=utf-8>
<title>Animatable.getAnimationPlayers() method tests</title>
<meta name="assert" content="Returns the set of AnimationPlayer objects whose source content is current and contains at least one animation whose animation target is this object">
<link rel="help" href="http://w3c.github.io/web-animations/#dom-animatable-getanimationplayers">
<link rel="author" title="Sergey G. Grekhov" href="mailto:sgrekhov@unipro.ru">
<script src="/resources/testharness.js"></script>
<script src="/resources/testharnessreport.js"></script>
<script src="../testcommon.js"></script>
<link rel="stylesheet" href="/resources/testharness.css">
<body>
<div id="log"></div>
<script>
test(function() {
    var animatableElements = [createDiv(this), createPseudoElement(this)];
    animatableElements.forEach(function(animatable, index) {
        var player = animatable.animate(null);
        var players = animatable.getAnimationPlayers();
        assert_array_equals(players, [player], 'Element ' + index + ': ' +
            'Animatable.getAnimationPlayers() method should return all players whose ' +
            'source content contains animation whose animation target is this object');
    });
}, 'Animatable.getAnimationPlayers() method returns single player whose source content ' +
    'contains animation whose animation target is this object. Animation is created ' +
    'by Animatable.animate() call');

test(function() {
    var animatableElements = [createDiv(this), createPseudoElement(this)];
    animatableElements.forEach(function(animatable, index) {
        var animation = new Animation(animatable, KEYFRAMES, ANIMATION_DURATION);
        var player = document.timeline.play(animation);
        var players = animatable.getAnimationPlayers();
        assert_array_equals(players, [player], 'Element ' + index + ': ' +
            'Animatable.getAnimationPlayers() method should return all players whose ' +
            'source content contains animation whose animation target is this object');
    });
}, 'Animatable.getAnimationPlayers() method returns single player whose source content ' +
    'contains animation whose animation target is this object. Animation is created ' +
    'by Animation constructor');

test(function() {
    var animatableElements = [[createDiv(this), createDiv(this)],
        [createPseudoElement(this), createPseudoElement(this)]];
    animatableElements.forEach(function(animatables, index) {
        var player1 = animatables[0].animate(null);
        var player2 = animatables[0].animate(null);
        var player3 = animatables[1].animate(null);
        var players = animatables[0].getAnimationPlayers();

        assert_array_equals(players, [player1, player2], 'Element ' + index + ': ' +
            'Animatable.getAnimationPlayers() method should return all players whose ' +
            'source content contains animation whose animation target is this object ' +
            'and sorted in increasing order by player sequence number');
    });
}, 'Animatable.getAnimationPlayers() method should return all players whose source ' +
    'content contains animation whose animation target is this object and sorted in ' +
    'increasing order by player sequence number. Players are created by Animatable.animate()');

test(function() {
    var animatableElements = [[createDiv(this), createDiv(this)],
        [createPseudoElement(this), createPseudoElement(this)]];
    animatableElements.forEach(function(animatables, index) {
        var player1 = document.timeline.play(new Animation(animatables[0], KEYFRAMES, ANIMATION_DURATION));
        var player2 = document.timeline.play(new Animation(animatables[0], KEYFRAMES, ANIMATION_DURATION));
        var player3 = document.timeline.play(new Animation(animatables[1], KEYFRAMES, ANIMATION_DURATION));
        var players = animatables[0].getAnimationPlayers();

        assert_array_equals(players, [player1, player2], 'Element ' + index + ': ' +
            'Animatable.getAnimationPlayers() method should return all players whose ' +
            'source content contains animation whose animation target is this object ' +
            'and sorted in increasing order by player sequence number');
    });
}, 'Animatable.getAnimationPlayers() method should return all players whose source ' +
    'content contains animation whose animation target is this object and sorted in ' +
    'increasing order by player sequence number. Animations are created by ' +
    'Animation constructor');

test(function() {
    var animatableElements = [createDiv(this), createPseudoElement(this)];
    animatableElements.forEach(function(animatable, index) {
        var player1 = animatable.animate(null);
        var player2 = animatable.animate(null);
        // this animation is not current, so it won't be returned by getAnimationPlayers()
        var animation = new Animation(animatable, KEYFRAMES, ANIMATION_DURATION);
        var players = animatable.getAnimationPlayers();

        assert_array_equals(players, [player1, player2], 'Element ' + index +
            ': Animatable.getAnimationPlayers() method should return only those players ' +
            'whose source content is current');
    });
}, 'Test that Animatable.getAnimationPlayers() method returns only those players ' +
    'whose source content is current. Animations are created by Animatable.animate() call');

test(function() {
    var animatableElements = [createDiv(this), createPseudoElement(this)];
    animatableElements.forEach(function(animatable, index) {
        var player1 = document.timeline.play(new Animation(animatable, KEYFRAMES, ANIMATION_DURATION));
        var player2 = document.timeline.play(new Animation(animatable, KEYFRAMES, ANIMATION_DURATION));
        // this animation is not current, so it won't be returned by getCurrentAnimations()
        var animation3 = new Animation(animatable, KEYFRAMES, ANIMATION_DURATION);
        var players = animatable.getAnimationPlayers();

        assert_array_equals(players, [player1, player2], 'Element ' + index +
            ': Animatable.getAnimationPlayers() method should return only those players ' +
            'whose source content is current');
    });
}, 'Test that Animatable.getAnimationPlayers() method returns only those players ' +
    'whose source content is current. Animations are created by Animation constructor');

test(function() {
    var animatableElements = [createDiv(this), createPseudoElement(this)];
    animatableElements.forEach(function(animatable, index) {
        var animation1 = new Animation(animatable, KEYFRAMES, ANIMATION_DURATION);
        var animation2 = new Animation(animatable, KEYFRAMES, ANIMATION_DURATION);
        var animationGroup = new AnimationGroup([animation1, animation2]);
        var player = document.timeline.play(animationGroup);
        var players = animatable.getAnimationPlayers();

        assert_array_equals(players, [player], 'Element ' + index + ': ' +
            'Player returned by Animatable.getAnimationPlayers() method should ' +
            'appear in the returned list once');
    });
}, 'Test that If this object is the animation target of two or more animations ' +
    'which are associated with the same player, the corresponding AnimationPlayer ' +
    'object will still only appear in the returned list once. Test AnimationGroup');

test(function() {
    var animatableElements = [createDiv(this), createPseudoElement(this)];
    animatableElements.forEach(function(animatable, index) {
        var animation1 = new Animation(animatable, KEYFRAMES, ANIMATION_DURATION);
        var animation2 = new Animation(animatable, KEYFRAMES, ANIMATION_DURATION);
        var animationSequence = new AnimationSequence([animation1, animation2]);
        var player = document.timeline.play(animationSequence);
        var players = animatable.getAnimationPlayers();

        assert_array_equals(players, [player], 'Element ' + index + ': ' +
            'Player returned by Animatable.getAnimationPlayers() method should ' +
            'appear in the returned list once');
    });
}, 'Test that If this object is the animation target of two or more animations ' +
    'which are associated with the same player, the corresponding AnimationPlayer ' +
    'object will still only appear in the returned list once. Test AnimationSequence');

test(function() {
    var animatableElements = [createDiv(this), createPseudoElement(this)];
    animatableElements.forEach(function(animatable, index) {
        var animation1 = new Animation(animatable, KEYFRAMES, ANIMATION_DURATION);
        var animation2 = new Animation(animatable, KEYFRAMES, ANIMATION_DURATION);
        var animation3 = new Animation(animatable, KEYFRAMES, ANIMATION_DURATION);
        var animation4 = new Animation(animatable, KEYFRAMES, ANIMATION_DURATION);
        var childGroup = new AnimationGroup([animation3, animation4]);
        var animationGroup = new AnimationGroup([animation1, animation2, childGroup]);
        var player = document.timeline.play(animationGroup);
        var players = animatable.getAnimationPlayers();

        assert_array_equals(players, [player], 'Element ' + index + ': ' +
            'Player returned by Animatable.getAnimationPlayers() method should ' +
            'appear in the returned list once');
    });
}, 'Test that If this object is the animation target of two or more animations ' +
    'which are associated with the same player, the corresponding AnimationPlayer ' +
    'object will still only appear in the returned list once. Test AnimationGroup ' +
    'with child group');

test(function() {
    var animatableElements = [createDiv(this), createPseudoElement(this)];
    animatableElements.forEach(function(animatable, index) {
        var animation1 = new Animation(animatable, KEYFRAMES, ANIMATION_DURATION);
        var animation2 = new Animation(animatable, KEYFRAMES, ANIMATION_DURATION);
        var animation3 = new Animation(animatable, KEYFRAMES, ANIMATION_DURATION);
        var animation4 = new Animation(animatable, KEYFRAMES, ANIMATION_DURATION);
        var childSequence = new AnimationSequence([animation3, animation4]);
        var animationSequence = new AnimationSequence([animation1, animation2, childSequence]);
        var player = document.timeline.play(animationSequence);
        var players = animatable.getAnimationPlayers();

        assert_array_equals(players, [player], 'Element ' + index + ': ' +
            'Player returned by Animatable.getAnimationPlayers() method should ' +
            'appear in the returned list once');
    });
}, 'Test that If this object is the animation target of two or more animations ' +
    'which are associated with the same player, the corresponding AnimationPlayer ' +
    'object will still only appear in the returned list once. Test AnimationSequence ' +
    'with child sequence');

test(function() {
    var animatableElements = [createDiv(this), createPseudoElement(this)];
    animatableElements.forEach(function(animatable, index) {
        var animation1 = new Animation(animatable, KEYFRAMES, ANIMATION_DURATION);
        var animation2 = new Animation(animatable, [], {
            duration: ANIMATION_DURATION,
            fill: 'forwards'});
        var player1 = document.timeline.play(animation1);
        var player2 = document.timeline.play(animation2);

        player1.ready.then(t.step_func(function() {
            player2.ready.then(t.step_func(function() {
                player2.currentTime = ANIMATION_DURATION / 2;
                var players = aniatable.getAnimationPlayers();
                assert_array_equals(players, [player1, player2], 'Element ' + index + ': ' +
                    'Animatable.getAnimationPlayers() method should include those players ' +
                    'whose source content is current');

                player2.currentTime = ANIMATION_DURATION;
                players = aniatable.getAnimationPlayers();
                assert_array_equals(players, [player1], 'Element ' + index + ': ' +
                    'Animatable.getAnimationPlayers() method should not include those players ' +
                    'whose source content is not current');

                player2.currentTime = ANIMATION_DURATION + 100;
                players = aniatable.getAnimationPlayers();
                assert_array_equals(players, [player1], 'Element ' + index + ': ' +
                    'Animatable.getAnimationPlayers() method should not include those players ' +
                    'whose source content is not current');
            }), t.unreached_func('Current ready promise should not be rejected'));
        }), t.unreached_func('Current ready promise should not be rejected'));
    });
}, 'Animatable.getAnimationPlayers() method does not include those players whose ' +
    'source content is not current');

test(function() {
    var animatableElements = [createDiv(this), createPseudoElement(this)];
    animatableElements.forEach(function(animatable, index) {
        var animation1 = new Animation(animatable, KEYFRAMES, ANIMATION_DURATION);
        var animation2 = new Animation(animatable, KEYFRAMES, ANIMATION_DURATION);
        var player1 = document.timeline.play(animation1);
        var player2 = document.timeline.play(animation2);

        player1.ready.then(t.step_func(function() {
            player2.ready.then(t.step_func(function() {
                player2.currentTime = -100;
                var players = aniatable.getAnimationPlayers();
                assert_array_equals(players, [player1, player2],  'Element ' + index + ': ' +
                    'Animatable.getAnimationPlayers() method should include those players ' +
                    'whose source content is current');

                player2.currentTime = ANIMATION_DURATION;
                players = aniatable.getAnimationPlayers();
                assert_array_equals(players, [player1],  'Element ' + index + ': ' +
                    'Animatable.getAnimationPlayers() method should not include those players ' +
                    'whose source content is not current');

                player2.currentTime = ANIMATION_DURATION + 100;
                players = aniatable.getAnimationPlayers();
                assert_array_equals(players, [player1],  'Element ' + index + ': ' +
                    'Animatable.getAnimationPlayers() method should not include those players ' +
                    'whose source content is not current');
            }), t.unreached_func('Current ready promise should not be rejected'));
        }), t.unreached_func('Current ready promise should not be rejected'));
    });
}, 'Animatable.getAnimationPlayers() method includes only those players whose source ' +
    'content is current');
</script>
</body>
