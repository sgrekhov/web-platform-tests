<!DOCTYPE html>
<meta charset=utf-8>
<title>Animatable.getAnimationPlayers() method tests</title>
<meta name="assert" content="Returns the set of AnimationPlayer objects whose source content is current and contains at least one animation whose animation target is this object">
<link rel="help" href="http://w3c.github.io/web-animations/#dom-animatable-getanimationplayers">
<link rel="author" title="Sergey G. Grekhov" href="mailto:sgrekhov@unipro.ru">
<script src="/resources/testharness.js"></script>
<script src="/resources/testharnessreport.js"></script>
<script src="../testcommon.js"></script>
<link rel="stylesheet" href="/resources/testharness.css">
<body>
<div id="log"></div>
<script>
async_test(function(t) {
    var animatableElements = [createDiv(t), createPseudoElement(t)];
    var doneCounter = 0;
    animatableElements.forEach(function(animatable, index) {
        var player = animatable.animate(null);
        player.ready.then(t.step_func(function() {
            var players = animatable.getAnimationPlayers();
            assert_array_equals(players, [player], 'Element ' + index + ': ' +
                'Animatable.getAnimationPlayers() method should return all players whose ' +
                'source content contains animation and whose animation target is this object');
            doneCounter++;
            if (doneCounter === animatableElements.length) {
                t.done();
            }
        }), t.unreached_func('Current ready promise should not be rejected'));
    });
}, 'Animatable.getAnimationPlayers() method returns single player whose source content ' +
    'contains animation whose animation target is this object. Animation is created ' +
    'by Animatable.animate() call');

async_test(function(t) {
    var animatableElements = [createDiv(t), createPseudoElement(t)];
    var doneCounter = 0;
    animatableElements.forEach(function(animatable, index) {
        var animation = new Animation(animatable, KEYFRAMES, ANIMATION_DURATION);
        var player = document.timeline.play(animation);
        player.ready.then(t.step_func(function() {
            var players = animatable.getAnimationPlayers();
            assert_array_equals(players, [player], 'Element ' + index + ': ' +
                'Animatable.getAnimationPlayers() method should return all players whose ' +
                'source content contains animation whose animation target is this object');
            doneCounter++;
            if (doneCounter === animatableElements.length) {
                t.done();
            }
        }), t.unreached_func('Current ready promise should not be rejected'));
    });
}, 'Animatable.getAnimationPlayers() method returns single player whose source content ' +
    'contains animation whose animation target is this object. Animation is created ' +
    'by Animation constructor');

async_test(function(t) {
    var animatableElements = [[createDiv(t), createDiv(t)],
        [createPseudoElement(t), createPseudoElement(t)]];
    var doneCounter = 0;
    animatableElements.forEach(function(animatables, index) {
        var player1 = animatables[0].animate(null);
        var player2 = animatables[0].animate(null);
        var player3 = animatables[1].animate(null);

        Promise.all([player1.ready, player2.ready, player3.ready]).then(t.step_func(function() {
            var players = animatables[0].getAnimationPlayers();

            assert_array_equals(players, [player1, player2], 'Element ' + index + ': ' +
                'Animatable.getAnimationPlayers() method should return all players whose ' +
                'source content contains animation whose animation target is this object ' +
                'and sorted in increasing order by player sequence number');
            doneCounter++;
            if (doneCounter === animatableElements.length) {
                t.done();
            }
        }), t.unreached_func('Player ready promise should not be rejected'));
    });
}, 'Animatable.getAnimationPlayers() method should return all players whose source ' +
    'content contains animation whose animation target is this object and sorted in ' +
    'increasing order by player sequence number. Players are created by Animatable.animate()');

async_test(function(t) {
    var animatableElements = [[createDiv(t), createDiv(t)],
        [createPseudoElement(t), createPseudoElement(t)]];
    var doneCounter = 0;
    animatableElements.forEach(function(animatables, index) {
        var player1 = document.timeline.play(new Animation(animatables[0], KEYFRAMES, ANIMATION_DURATION));
        var player2 = document.timeline.play(new Animation(animatables[0], KEYFRAMES, ANIMATION_DURATION));
        var player3 = document.timeline.play(new Animation(animatables[1], KEYFRAMES, ANIMATION_DURATION));

        Promise.all([player1.ready, player2.ready, player3.ready]).then(t.step_func(function() {
            var players = animatables[0].getAnimationPlayers();

            assert_array_equals(players, [player1, player2], 'Element ' + index + ': ' +
                'Animatable.getAnimationPlayers() method should return all players whose ' +
                'source content contains animation whose animation target is this object ' +
                'and sorted in increasing order by player sequence number');
            doneCounter++;
            if (doneCounter === animatableElements.length) {
                t.done();
            }
        }), t.unreached_func('Player ready promise should not be rejected'));
    });
}, 'Animatable.getAnimationPlayers() method should return all players whose source ' +
    'content contains animation whose animation target is this object and sorted in ' +
    'increasing order by player sequence number. Animations are created by ' +
    'Animation constructor');

async_test(function(t) {
    var animatableElements = [createDiv(this), createPseudoElement(this)];
    animatableElements.forEach(function(animatable, index) {
        var animation1 = new Animation(animatable, KEYFRAMES, ANIMATION_DURATION);
        var animation2 = new Animation(animatable, KEYFRAMES, {
            duration: ANIMATION_DURATION,
            fill: 'forwards'});
        var player1 = document.timeline.play(animation1);
        var player2 = document.timeline.play(animation2);

        Promise.all([player1.ready, player2.ready]).then(t.step_func(function() {
            player2.currentTime = ANIMATION_DURATION / 2;
            var players = aniatable.getAnimationPlayers();
            assert_array_equals(players, [player1, player2], 'Element ' + index + ': ' +
                'Animatable.getAnimationPlayers() method should include those players ' +
                'whose source content is in effect');

            player2.currentTime = ANIMATION_DURATION;
            players = aniatable.getAnimationPlayers();
            assert_array_equals(players, [player1, player2], 'Element ' + index + ': ' +
                'Animatable.getAnimationPlayers() method should not include those players ' +
                'whose source content is not current and not in effect');

            player2.currentTime = ANIMATION_DURATION + 100;
            players = aniatable.getAnimationPlayers();
            assert_array_equals(players, [player1, player2], 'Element ' + index + ': ' +
                'Animatable.getAnimationPlayers() method should not include those players ' +
                'whose source content is not current and not in effect');
            doneCounter++;
            if (doneCounter === animatableElements.length) {
                t.done();
            }
        }), t.unreached_func('Player ready promise should not be rejected'));
    });
}, 'Animatable.getAnimationPlayers() method does not include those players whose ' +
    'source content is not current and not in effect');

test(function() {
    var animatableElements = [createDiv(this), createPseudoElement(this)];
    animatableElements.forEach(function(animatable, index) {
        var animation1 = new Animation(animatable, KEYFRAMES, ANIMATION_DURATION);
        var animation2 = new Animation(animatable, KEYFRAMES, ANIMATION_DURATION);
        var player1 = document.timeline.play(animation1);
        var player2 = document.timeline.play(animation2);

        Promise.all([player1.ready, player2.ready]).then(t.step_func(function() {
            player2.currentTime = -100;
            var players = aniatable.getAnimationPlayers();
            assert_array_equals(players, [player1, player2],  'Element ' + index + ': ' +
                'Animatable.getAnimationPlayers() method should include those players ' +
                'whose source content is current');

            player2.currentTime = ANIMATION_DURATION / 2;
            players = aniatable.getAnimationPlayers();
            assert_array_equals(players, [player1, player2],  'Element ' + index + ': ' +
                'Animatable.getAnimationPlayers() method should include those players ' +
                'whose source content is current');

            player2.currentTime = ANIMATION_DURATION;
            players = aniatable.getAnimationPlayers();
            assert_array_equals(players, [player1],  'Element ' + index + ': ' +
                'Animatable.getAnimationPlayers() method should not include those players ' +
                'whose source content is not current and not in effect');
        }), t.unreached_func('Current ready promise should not be rejected'));
    });
}, 'Animatable.getAnimationPlayers() method includes only those players whose source ' +
    'content is current or in effect');
</script>
</body>
