<!DOCTYPE html>
<meta charset=utf-8>
<title>Test processing a sequence of Keyframe objects or a single item</title>
<meta name="assert" content="The processing of the frames parameter is defined in Processing a sequence of Keyframe objects or a single item">
<link rel="help" href="http://w3c.github.io/web-animations/#the-keyframeeffect-interface">
<link rel="help" href="http://w3c.github.io/web-animations/#dom-keyframeeffect-setframes">
<link rel="help" href="http://w3c.github.io/web-animations/#processing-a-sequence-of-keyframe-objects-or-a-single-item">
<link rel="author" title="Sergey G. Grekhov" href="mailto:sgrekhov@unipro.ru">
<link rel="author" title="Aleksei Yu. Semenov" href="mailto:a.semenov@unipro.ru">
<script src="/resources/testharness.js"></script>
<script src="/resources/testharnessreport.js"></script>
<script src="../testcommon.js"></script>
<link rel="stylesheet" href="/resources/testharness.css">
<body>
<div id="log"></div>
<script>
// Creates two effects that tested in the tests below. One with frames,
// defined by the constructor. And the second with keyframes defined by setFrames()
function createEffectsToTest(keyframes) {
    var effect1 = new KeyframeEffect(keyframes);
    var effect2 = new KeyframeEffect([]);
    effect2.setFrames(keyframes);
    return [effect1, effect2];
}
var effectsDescription = ['KeyframeEffect constructor', 'KeyframeEffect.setFrames()'];

// Utility function, which simply returns number value 0.4
function returnsInt0_4(){
    return 0.4;
}
// Utility function, which simply returns string value '0.7'
function returnsString0_7() {
    return '0.7';
}
// Utility function, which simply returns string value 'X'
function returnsStringX() {
    return 'X';
}
// Utility function, which simply returns dummy object
function returnsObject() {
    return {};
}

//1. Let keyframe result be a Keyframe object with the offset, easing and composite attributes
// set to the default dictionary values.
test(function() {
    var effects = createEffectsToTest({});
    var keyframes = [{offset: null, easing: 'linear', composite: null, computedOffset: 0}];
    effects.forEach(function(effect, index) {
        assert_array_equals(effect.getFrames(), keyframes,
            effectsDescription[index] + ' should set Keyframe attributes to default values');
    });
}, 'Test processing of keyframes sets set Keyframe attributes to default values. ' +
    'Input is a single object');

test(function() {
    var effects = createEffectsToTest([{}, {}]);
    var keyframes = [
        {offset: null, easing: 'linear', composite: null, computedOffset: 0},
        {offset: null, easing: 'linear', composite: null, computedOffset: 1}
    ];
    effects.forEach(function(effect, index) {
        assert_array_equals(effect.getFrames(), keyframes,
            effectsDescription[index] + ' should set Keyframe attributes to default values');
    });
}, 'Test processing of keyframes sets set Keyframe attributes to default values. ' +
    'Input is a sequence of objects');

//2. Create a list, supported properties, of property names and attribute names that can be animated by the implementation.
//3. Convert each property name in supported properties to the equivalent IDL attribute by applying the CSS property to IDL attribute algorithm [CSSOM].
//4. If the user agent supports animation of the float CSS property, replace "float" in supported properties with "cssFloat".
//5. Let animation properties be an empty sequence.
//6. Use the internal [[Enumerate]] operation on keyframe input to iterate over its properties.
//For each property perform the step corresponding to the first matching condition from below, if any.
//    If property is a case-sensitive match for the string "offset",
test(function() {
    var effects = createEffectsToTest({oFFset: 0.5});
    var keyframes = [{offset: null, easing: 'linear', composite: null, computedOffset: 0}];
    effects.forEach(function(effect, index) {
        assert_array_equals(effect.getFrames(), keyframes,
            effectsDescription[index] + ' should set Keyframe attributes to default values');
    });
}, 'Test processing of keyframes match atribute \'offset\' case-sensitevly. ' +
    'Input is a single object');

test(function() {
    var effects = createEffectsToTest([{oFFset: 0.5}, {offSET: 0.5}]);
    var keyframes = [
        {offset: null, easing: 'linear', composite: null, computedOffset: 0},
        {offset: null, easing: 'linear', composite: null, computedOffset: 1}
    ];
    effects.forEach(function(effect, index) {
        assert_array_equals(effect.getFrames(), keyframes,
            effectsDescription[index] + ' should set Keyframe attributes to default values');
    });
}, 'Test processing of keyframes match atribute \'offset\' case-sensitevly. ' +
    'Input is a sequence of objects');

// Set the offset member of keyframe result to the result of applying the procedure for
// converting an ECMAScript value into an IDL double [WEBIDL] to the result of calling the
// [[Get]] internal method on keyframe input with property name "offset".
test(function() {
    var values = [null, true, false, 0.3, '0.5',
        {valueOf: returnsInt0_4},
        {valueOf: returnsInt0_4, toString: returnsString0_7},
        {valueOf: returnsInt0_4, toString: 'not callable'},
        {valueOf: returnsString0_7},
        {toString: returnsString0_7},
        {valueOf: 'not callable', toString: returnsString0_7},
        {valueOf: returnsObject, toString: returnsString0_7},
        {valueOf: returnsInt0_4, toString: returnsObject}];
    var expected = [0, 1, 0, 0.3, 0.5, 0.4, 0.4, 0.4, 0.7, 0.7, 0.7, 0.7, 0.4];
    values.forEach(function(value, index1) {
        var effects = createEffectsToTest({offset: value});
        var keyframes = [
            {offset: expected[index1], easing: 'linear', composite: null,
                computedOffset: expected[index1]}
        ];
        effects.forEach(function(effect, index2) {
            assert_array_equals(effect.getFrames(), keyframes,
                effectsDescription[index2] + ' should set Keyframe attribute \'offset\'');
        });
    });
}, 'Test processing of keyframes converts atribute \'offset\' value to IDL double. ' +
    'Input is a single object');

test(function() {
    var values = [null, true, false, 0.3, '0.5',
        {valueOf: returnsInt0_4},
        {valueOf: returnsInt0_4, toString: returnsString0_7},
        {valueOf: returnsInt0_4, toString: 'not callable'},
        {valueOf: returnsString0_7},
        {toString: returnsString0_7},
        {valueOf: 'not callable', toString: returnsString0_7},
        {valueOf: returnsObject, toString: returnsString0_7},
        {valueOf: returnsInt0_4, toString: returnsObject}];
    var expected = [0, 1, 0, 0.3, 0.5, 0.4, 0.4, 0.4, 0.7, 0.7, 0.7, 0.7, 0.4];
    values.forEach(function(value, index1) {
        var effects = createEffectsToTest([{offset: value}, {offset: value}]);
        var keyframes = [
            {offset: expected[index1], easing: 'linear', composite: null, computedOffset: expected[index1]},
            {offset: expected[index1], easing: 'linear', composite: null, computedOffset: expected[index1]}
        ];
        effects.forEach(function(effect, index2) {
            assert_array_equals(effect.getFrames(), keyframes,
                effectsDescription[index2] + ' should set Keyframe attribute \'offset\'');
        });
    });
}, 'Test processing of keyframes converts atribute \'offset\' value to IDL double. ' +
    'Input is a sequence of objects');

test(function() {
    var values = [NaN, 1/0, -1/0, Infinity, -Infinity, undefined, ' ', 'a',
        'Infinity', '-Infinity', {},
        {valueOf: 'not callable', toString: 'not callable'},
        {valueOf: returnsObject, toString: returnsObject},
        {valueOf: returnsStringX},
        {valueOf: 'not callable', toString: returnsStringX},
        {valueOf: function() {return NaN;} },
        {valueOf: returnsObject, toString: function() {return NaN;}}];
    values.forEach(function(value) {
        assert_throws('TypeError', function() {
            new KeyframeEffect({offset: value});
        }, 'KeyframeEffect constructor should throw TypeError for not numeric ' +
            'attribute \'offset\' value ' + value);
    });
}, 'Test KeyframeEffect constructor throws TypeError if atribute \'offset\' value ' +
    'is not numeric. Input is a single object');

test(function() {
    var values = [NaN, 1/0, -1/0, Infinity, -Infinity, undefined, ' ', 'a',
        'Infinity', '-Infinity', {},
        {valueOf: 'not callable', toString: 'not callable'},
        {valueOf: returnsObject, toString: returnsObject},
        {valueOf: returnsStringX},
        {valueOf: 'not callable', toString: returnsStringX},
        {valueOf: function() {return NaN;} },
        {valueOf: returnsObject, toString: function() {return NaN;}}];
    values.forEach(function(value) {
        assert_throws('TypeError', function() {
            new KeyframeEffect([{offset: 0}, {offset: value}]);
        }, 'KeyframeEffect constructor should throw TypeError for not numeric ' +
            'attribute \'offset\' value ' + value);
    });
}, 'Test KeyframeEffect constructor throws TypeError if atribute \'offset\' value ' +
    'is not numeric. Input is a sequence of objects');

test(function() {
    var values = [NaN, 1/0, -1/0, Infinity, -Infinity, undefined, ' ', 'a',
        'Infinity', '-Infinity', {},
        {valueOf: 'not callable', toString: 'not callable'},
        {valueOf: returnsObject, toString: returnsObject},
        {valueOf: returnsStringX},
        {valueOf: 'not callable', toString: returnsStringX},
        {valueOf: function() {return NaN;} },
        {valueOf: returnsObject, toString: function() {return NaN;}}];
    values.forEach(function(value) {
        assert_throws('TypeError', function() {
            new KeyframeEffect().setFrames({offset: value});
        }, 'KeyframeEffect.setFrames() should throw TypeError for not numeric ' +
            'attribute \'offset\' value ' + value);
    });
}, 'Test KeyframeEffect.setFrames() throws TypeError if atribute \'offset\' value ' +
    'is not numeric. Input is a single object');

test(function() {
    var values = [NaN, 1/0, -1/0, Infinity, -Infinity, undefined, ' ', 'a',
        'Infinity', '-Infinity', {},
        {valueOf: 'not callable', toString: 'not callable'},
        {valueOf: returnsObject, toString: returnsObject},
        {valueOf: returnsStringX},
        {valueOf: 'not callable', toString: returnsStringX},
        {valueOf: function() {return NaN;} },
        {valueOf: returnsObject, toString: function() {return NaN;}}];
    values.forEach(function(value) {
        assert_throws('TypeError', function() {
            new KeyframeEffect().setFrames([{offset: 0}, {offset: value}]);
        }, 'KeyframeEffect.setFrames() should throw TypeError for not numeric ' +
            'attribute \'offset\' value ' + value);
    });
}, 'Test KeyframeEffect.setFrames() throws TypeError if atribute \'offset\' value ' +
    'is not numeric. Input is a sequence of objects');

// If property is a case-sensitive match for the string "easing",
test(function() {
    var effects = createEffectsToTest({eAsing: 'hard'});
    var keyframes = [{offset: null, easing: 'linear', composite: null, computedOffset: 0}];
    effects.forEach(function(effect, index) {
        assert_array_equals(effect.getFrames(), keyframes,
            effectsDescription[index] + ' should set Keyframe attributes to default values');
    });
}, 'Test processing of keyframes match atribute \'easing\' case-sensitevly. ' +
    'Input is a single object');

test(function() {
    var effects = createEffectsToTest([{eAsing: 'hard'}, {eaSING: 'harder'}]);
    var keyframes = [
        {offset: null, easing: 'linear', composite: null, computedOffset: 0},
        {offset: null, easing: 'linear', composite: null, computedOffset: 1}
    ];
    effects.forEach(function(effect, index) {
        assert_array_equals(effect.getFrames(), keyframes,
            effectsDescription[index] + ' should set Keyframe attributes to default values');
    });
}, 'Test processing of keyframes match atribute \'easing\' case-sensitevly. ' +
    'Input is a sequence of objects');

// Set the easing member of keyframe result to the result of applying the procedure for
// converting an ECMAScript value to an IDL DOMString value [WEBIDL] with the
// [TreatNullAs=EmptyString] annotation in effect, to the result of calling the
// [[Get]] internal method of keyframe input with property name "easing".
test(function() {
    var values = [
        'linear', 'ease', 'ease-in', 'ease-out', 'ease-in-out', 'cubic-bezier(0.5, 0, 0.5, 1)',
        'step-start', 'step-middle', 'step-end', 'steps(2), steps(2, middle)',
        {toString: function() { return 'ease-in';}},
        {toString: 'not callable', valueOf: function() { return 'ease-out';}},
        {toString: returnsObject, valueOf: function() { return 'ease-in-out';}}
    ];
    var expected = [
        'linear', 'ease', 'ease-in', 'ease-out', 'ease-in-out', 'cubic-bezier(0.5, 0, 0.5, 1)',
        'step-start', 'step-middle', 'step-end', 'steps(2), steps(2, middle)',
        'ease-in', 'ease-out', 'ease-in-out'
    ];
    values.forEach(function(value, index1) {
        var effects = createEffectsToTest({easing: value});
        var keyframes = [
            {offset: null, easing: expected[index1], composite: null, computedOffset: 0}
        ];
        effects.forEach(function(effect, index2) {
            assert_array_equals(effect.getFrames(), keyframes,
                effectsDescription[index2] + ' should set Keyframe attribute ' +
                'easing\' to \'' + expected[index1] + '\'');
        });
    });
}, 'Test processing of keyframes sets atribute \'easing\' to specified value. ' +
    'Input is a single object');

test(function() {
    var values = [
        'linear', 'ease', 'ease-in', 'ease-out', 'ease-in-out', 'cubic-bezier(0.5, 0, 0.5, 1)',
        'step-start', 'step-middle', 'step-end', 'steps(2), steps(2, middle)',
        {toString: function() { return 'ease-in';}},
        {toString: 'not callable', valueOf: function() { return 'ease-out';}},
        {toString: returnsObject, valueOf: function() { return 'ease-in-out';}},
        {valueOf: function() { return 'step-start';}}
    ];
    var expected = [
        'linear', 'ease', 'ease-in', 'ease-out', 'ease-in-out', 'cubic-bezier(0.5, 0, 0.5, 1)',
        'step-start', 'step-middle', 'step-end', 'steps(2), steps(2, middle)',
        'ease-in', 'ease-out', 'ease-in-out', 'step-start'
    ];
    values.forEach(function(value, index1) {
        var effects = createEffectsToTest([{easing: value}, {easing: value}]);
        var keyframes = [
            {offset: null, easing: expected[index1], composite: null, computedOffset: 0},
            {offset: null, easing: expected[index1], composite: null, computedOffset: 1}
        ];
        effects.forEach(function(effect, index2) {
            assert_array_equals(effect.getFrames(), keyframes,
                effectsDescription[index2] + ' should set Keyframe attribute ' +
                'easing\' to \'' + expected[index1] + '\'');
        });
    });
}, 'Test processing of keyframes sets atribute \'easing\' to specified value. ' +
    'Input is a sequence of objects');

// If the resulting string does not conform to the grammar defined for the easing attribute
// of the AnimationTiming interface or is not supported by the implementation, then set
// the easing of keyframe result to the string “linear”.
test(function() {
    var values = [
        {toString: 'not callable', valueOf: 'not callable'},
        {toString: returnsObject, valueOf: 'not callable'},
        {toString: 'not callable', valueOf: returnsObject},
        {toString: returnsObject, valueOf: returnsObject}
    ];
    values.forEach(function(value) {
        assert_throws('TypeError', function() {
             new KeyframeEffect({easing: value});
        }, 'TypeError should be thrown for \'easing\' value ' + value);
    });
}, 'Test KeyframeEffect constructor throws TypeError if atribute \'easing\' value ' +
    'can not be converted to string value. Input is a single object');

test(function() {
    var values = [
        {toString: 'not callable', valueOf: 'not callable'},
        {toString: returnsObject, valueOf: 'not callable'},
        {toString: 'not callable', valueOf: returnsObject},
        {toString: returnsObject, valueOf: returnsObject}
    ];
    values.forEach(function(value) {
        assert_throws('TypeError', function() {
             new KeyframeEffect().setFrames({easing: value});
        }, 'TypeError should be thrown for \'easing\' value ' + value);
    });
}, 'Test KeyframeEffect.setFrames() throws TypeError if atribute \'easing\' value ' +
    'can not be converted to string value. Input is a single object');

test(function() {
    var values = [
        {toString: 'not callable', valueOf: 'not callable'},
        {toString: returnsObject, valueOf: 'not callable'},
        {toString: 'not callable', valueOf: returnsObject},
        {toString: returnsObject, valueOf: returnsObject}
    ];
    values.forEach(function(value) {
        assert_throws('TypeError', function() {
             new KeyframeEffect([{easing: value}, {easing: value}]);
        }, 'TypeError should be thrown for \'easing\' value ' + value);
    });
}, 'Test KeyframeEffect constructor throws TypeError if atribute \'easing\' value ' +
    'can not be converted to string value. Input is a sequence of objects');

test(function() {
    var values = [
        {toString: 'not callable', valueOf: 'not callable'},
        {toString: returnsObject, valueOf: 'not callable'},
        {toString: 'not callable', valueOf: returnsObject},
        {toString: returnsObject, valueOf: returnsObject}
    ];
    values.forEach(function(value) {
        assert_throws('TypeError', function() {
             new KeyframeEffect().setFrames([{easing: value}, {easing: value}]);
        }, 'TypeError should be thrown for \'easing\' value ' + value);
    });
}, 'Test KeyframeEffect.setFrames() throws TypeError if atribute \'easing\' value ' +
    'can not be converted to string value. Input is a sequence of objects');

test(function() {
    var values = [
        null, undefined, true, false, 0.3, 'hard', {},
        {toString: returnsStringX},
        {toString: returnsString0_7},
        {toString: 'not callable', valueOf: returnsInt0_4},
        {toString: returnsObject, valueOf: returnsStringX()},
        {a: 'b', c: 'd'}
    ];
    values.forEach(function(value) {
        var effects = createEffectsToTest({easing: value});
        var keyframes = [
            {offset: null, easing: 'linear', composite: null, computedOffset: 0}
        ];
        effects.forEach(function(effect, index) {
            assert_array_equals(effect.getFrames(), keyframes,
                effectsDescription[index] + ' should set Keyframe attribute \'easing\' to \'linear\'');
        });
    });
}, 'Test processing of keyframes sets atribute \'easing\' value to \'linear\', ' +
    'if input value is invalid. Input is a single object');

test(function() {
    var values = [
        null, undefined, true, false, 0.3, 'hard', {},
        {toString: returnsStringX},
        {toString: returnsString0_7},
        {toString: 'not callable', valueOf: returnsInt0_4},
        {toString: returnsObject, valueOf: returnsStringX()},
        {a: 'b', c: 'd'}
    ];
    values.forEach(function(value) {
        var effects = createEffectsToTest([{easing: value}, {easing: value}]);
        var keyframes = [
            {offset: null, easing: 'linear', composite: null, computedOffset: 0},
            {offset: null, easing: 'linear', composite: null, computedOffset: 1}
        ];
        effects.forEach(function(effect, index) {
            assert_array_equals(effect.getFrames(), keyframes,
                effectsDescription[index] + ' should set Keyframe attribute \'easing\' to \'linear\'');
        });
    });
}, 'Test processing of keyframes sets atribute \'easing\' value to \'linear\', ' +
    'if input value is invalid. Input is a sequence of objects');

// If property is a case-sensitive match for the string "composite",
test(function() {
    var effects = createEffectsToTest({cOmpOsite: 'material'});
    var keyframes = [{offset: null, easing: 'linear', composite: null, computedOffset: 0}];
    effects.forEach(function(effect, index) {
        assert_array_equals(effect.getFrames(), keyframes,
            effectsDescription[index] + ' should set Keyframe attributes to default values');
    });
}, 'Test processing of keyframes match atribute \'composite\' case-sensitevly. ' +
    'Input is a single object');

test(function() {
    var effects = createEffectsToTest([{cOmpOsite: 'material'}, {CompoSITE: 'magazine'}]);
    var keyframes = [
        {offset: null, easing: 'linear', composite: null, computedOffset: 0},
        {offset: null, easing: 'linear', composite: null, computedOffset: 1}
    ];
    effects.forEach(function(effect, index) {
        assert_array_equals(effect.getFrames(), keyframes,
            effectsDescription[index] + ' should set Keyframe attributes to default values');
    });
}, 'Test processing of keyframes match atribute \'composite\' case-sensitevly. ' +
    'Input is a sequence of objects');

// Set the composite member of keyframe result to the result applying the procedure for
// converting an ECMAScript value to an IDL enumeration type [WEBIDL] with CompositeOperation
// as the enumeration type, to the result of calling the [[Get]] internal method on keyframe
// input with property name "composite".
test(function() {
    var values = [
        'replace', 'add', 'accumulate',
        {toString: function() { return 'replace';}},
        {valueOf: function() { return 'add';}},
        {toString: 'not callable', valueOf: function() { return 'accumulate';}},
        {toString: returnsObject, valueOf: function() { return 'replace';}}
    ];
    var expected = [
        'replace', 'add', 'accumulate',
        'replace', 'add', 'accumulate',
        'replace'
    ];
    values.forEach(function(value, index1) {
        var effects = createEffectsToTest({composite: value});
        var keyframes = [
            {offset: null, easing: 'linear', composite: expected[index1], computedOffset: 0}
        ];
        effects.forEach(function(effect, index2) {
            assert_array_equals(effect.getFrames(), keyframes,
                effectsDescription[index2] + ' should set Keyframe attribute ' +
                'composite\' to \'' + expected[index1] + '\'');
        });
    });
}, 'Test processing of keyframes sets atribute \'composite\' to specified value. ' +
    'Input is a single object');

test(function() {
    var values = [
        'replace', 'add', 'accumulate',
        {toString: function() { return 'replace';}},
        {valueOf: function() { return 'add';}},
        {toString: 'not callable', valueOf: function() { return 'accumulate';}},
        {toString: returnsObject, valueOf: function() { return 'replace';}}
    ];
    var expected = [
        'replace', 'add', 'accumulate',
        'replace', 'add', 'accumulate',
        'replace'
    ];
    values.forEach(function(value, index1) {
        var effects = createEffectsToTest([{composite: value}, {composite: value}]);
        var keyframes = [
            {offset: null, easing: 'linear', composite: expected[index1], computedOffset: 0},
            {offset: null, easing: 'linear', composite: expected[index1], computedOffset: 1}
        ];
        effects.forEach(function(effect, index2) {
            assert_array_equals(effect.getFrames(), keyframes,
                effectsDescription[index2] + ' should set Keyframe attribute ' +
                'composite\' to \'' + expected[index1] + '\'');
        });
    });
}, 'Test processing of keyframes sets atribute \'composite\' to specified value. ' +
    'Input is a sequence of objects');

// test invalid input
 test(function() {
    var values = [
        'hello', 'composite', 0, 10, true, false, null, undefined, {},
        {a: 'b', c: 'd'},
        {toString: returnsStringX},
        {toString: 'not callable'},
        {toString: returnsObject},
        {valueOf: returnsStringX},
        {valueOf: 'not callable'},
        {valueOf: returnsObject},
        {toString: 'not callable', valueOf: 'not callable'},
        {toString: returnsObject, valueOf: returnsObject},
        {toString: returnsObject, valueOf: returnsStringX}
    ];
    values.forEach(function(value) {
        assert_throws('TypeError', function() {
            new KeyframeEffect({composite: value});
        }, 'KeyframeEffect constructor should throw TypeError for' +
            'attribute \'composite\' value ' + value);
    });
}, 'Test KeyframeEffect constructor throws TypeError if atribute \'composite\' value ' +
    'is not one of CompositeOperation enumeration values. Input is a single object');

test(function() {
    var values = [
        'hello', 'composite', 0, 10, true, false, null, undefined, {},
        {a: 'b', c: 'd'},
        {toString: returnsStringX},
        {toString: 'not callable'},
        {toString: returnsObject},
        {valueOf: returnsStringX},
        {valueOf: 'not callable'},
        {valueOf: returnsObject},
        {toString: 'not callable', valueOf: 'not callable'},
        {toString: returnsObject, valueOf: returnsObject},
        {toString: returnsObject, valueOf: returnsStringX}
    ];
    values.forEach(function(value) {
        assert_throws('TypeError', function() {
            new KeyframeEffect([{composite: 'add'}, {composite: value}]);
        }, 'KeyframeEffect constructor should throw TypeError for ' +
            'attribute \'composite\' value ' + value);
    });
}, 'Test KeyframeEffect constructor throws TypeError if atribute \'composite\' value ' +
    'is not one of CompositeOperation enumeration values. Input is a sequence of objects');

test(function() {
    var values = [
        'hello', 'composite', 0, 10, true, false, null, undefined, {},
        {a: 'b', c: 'd'},
        {toString: returnsStringX},
        {toString: 'not callable'},
        {toString: returnsObject},
        {valueOf: returnsStringX},
        {valueOf: 'not callable'},
        {valueOf: returnsObject},
        {toString: 'not callable', valueOf: 'not callable'},
        {toString: returnsObject, valueOf: returnsObject},
        {toString: returnsObject, valueOf: returnsStringX}
    ];
    values.forEach(function(value) {
        assert_throws('TypeError', function() {
            new KeyframeEffect().setFrames({composite: value});
        }, 'KeyframeEffect.setFrames() should throw TypeError for ' +
            'attribute \'composite\' value ' + value);
    });
}, 'Test KeyframeEffect.setFrames() throws TypeError if atribute \'composite\' value ' +
    'is not one of CompositeOperation enumeration values. Input is a single object');

test(function() {
    var values = [
        'hello', 'composite', 0, 10, true, false, null, undefined, {},
        {a: 'b', c: 'd'},
        {toString: returnsStringX},
        {toString: 'not callable'},
        {toString: returnsObject},
        {valueOf: returnsStringX},
        {valueOf: 'not callable'},
        {valueOf: returnsObject},
        {toString: 'not callable', valueOf: 'not callable'},
        {toString: returnsObject, valueOf: returnsObject},
        {toString: returnsObject, valueOf: returnsStringX}
    ];
    values.forEach(function(value) {
        assert_throws('TypeError', function() {
            new KeyframeEffect().setFrames([{composite: 'add'}, {composite: value}]);
        }, 'KeyframeEffect.setFrames() should throw TypeError for ' +
            'attribute \'composite\' value ' + value);
    });
}, 'Test KeyframeEffect.setFrames() throws TypeError if atribute \'composite\' value ' +
    'is not one of CompositeOperation enumeration values. Input is a sequence of objects');

// Otherwise, if property also exists in supported properties based on a case-sensitive comparison,
test(function() {
    var effects = createEffectsToTest({tOp: '10px'});
    var keyframes = [{offset: null, easing: 'linear', composite: null, computedOffset: 0}];
    effects.forEach(function(effect, index) {
        assert_array_equals(effect.getFrames(), keyframes,
            effectsDescription[index] + ' should set Keyframe attributes to default values');
    });
}, 'Test processing of keyframes match supported properties case-sensitevly. ' +
    'Input is a single object');

test(function() {
    var effects = createEffectsToTest([{tOp: '10px'}, {TOP: '10px'}]);
    var keyframes = [
        {offset: null, easing: 'linear', composite: null, computedOffset: 0},
        {offset: null, easing: 'linear', composite: null, computedOffset: 1}
    ];
    effects.forEach(function(effect, index) {
        assert_array_equals(effect.getFrames(), keyframes,
            effectsDescription[index] + ' should set Keyframe attributes to default values');
    });
}, 'Test processing of keyframes match supported properties case-sensitevly. ' +
    'Input is a sequence of objects');

// append property to animation properties.
// 7. For user agents that support both a prefixed and an unprefixed version of some CSS
// properties, remove all prefixed properties from animation properties
// where the corresponding unprefixed version is also present in animation properties.

// 8. Sort animation properties lexicographically by the Unicode codepoints that define each
// element.
// 9. Iterate over animation properties from beginning to end and
// for each name in animation properties add a new member pair to keyframe result as follows:
// member name: the result of applying the the IDL attribute to CSS property algorithm [CSSOM]
// to name
test(function() {
    var effects = createEffectsToTest({top: '10px'});
    var keyframes = [{top: '10px', offset: null, easing: 'linear', composite: null, computedOffset: 0}];
    effects.forEach(function(effect, index) {
        assert_array_equals(effect.getFrames(), keyframes,
            effectsDescription[index] + ' should set Keyframe attributes to default values ' +
            'and animation property \'top\'');
    });
}, 'Test processing of keyframes add supported properties to keyframe result. ' +
    'Input is a single object');

test(function() {
    var effects = createEffectsToTest([{top: '10px'}, {top: '20px'}]);
    var keyframes = [
        {top: '10px', offset: null, easing: 'linear', composite: null, computedOffset: 0},
        {top: '20px', offset: null, easing: 'linear', composite: null, computedOffset: 1}
    ];
    effects.forEach(function(effect, index) {
        assert_array_equals(effect.getFrames(), keyframes,
            effectsDescription[index] + ' should set Keyframe attributes to default values ' +
            'and animation property \'top\'');
    });
}, 'Test processing of keyframes add supported properties to keyframe result. ' +
    'Input is a sequence of objects');

test(function() {
    var effects = createEffectsToTest({backgroundOrigin: '10px'});
    var keyframes = [{'background-origin': '10px', offset: null, easing: 'linear', composite: null, computedOffset: 0}];
    effects.forEach(function(effect, index) {
        assert_array_equals(effect.getFrames(), keyframes,
            effectsDescription[index] + ' should set Keyframe attributes to default values ' +
            'and animation property \'background-origin\'');
    });
}, 'Test processing of keyframes add supported properties to keyframe result. ' +
    'Property name is converted by IDL attribute to CSS property algorithm. Input is a single object');

test(function() {
    var effects = createEffectsToTest([{backgroundOrigin: '10px'}, {backgroundOrigin: '20px'}]);
    var keyframes = [
        {'background-origin': '10px', offset: null, easing: 'linear', composite: null, computedOffset: 0},
        {'background-origin': '20px', offset: null, easing: 'linear', composite: null, computedOffset: 1}
    ];
    effects.forEach(function(effect, index) {
        assert_array_equals(effect.getFrames(), keyframes,
            effectsDescription[index] + ' should set Keyframe attributes to default values ' +
            'and animation property \'background-origin\'');
    });
}, 'Test processing of keyframes add supported properties to keyframe result. ' +
    'Property name is converted by IDL attribute to CSS property algorithm. Input is a sequence of objects');

// unless name is a case-sensitive match for the string "cssFloat" in which case use the string "float".
test(function() {
    var effects = createEffectsToTest({cssFloat: 'left'});
    var keyframes = [{float: 'left', offset: null, easing: 'linear', composite: null, computedOffset: 0}];
    effects.forEach(function(effect, index) {
        assert_array_equals(effect.getFrames(), keyframes,
            effectsDescription[index] + ' should set Keyframe attributes to default values ' +
            'and animation property \'float\'');
    });
}, 'Test processing of keyframes add property \'cssFloat\' to keyframe result as \'float\'. ' +
    'Input is a single object');

test(function() {
    var effects = createEffectsToTest([{cssFloat: 'left'}, {cssFloat: 'right'}]);
    var keyframes = [
        {float: 'left', offset: null, easing: 'linear', composite: null, computedOffset: 0},
        {float: 'right', offset: null, easing: 'linear', composite: null, computedOffset: 1}
    ];
    effects.forEach(function(effect, index) {
        assert_array_equals(effect.getFrames(), keyframes,
            effectsDescription[index] + ' should set Keyframe attributes to default values ' +
            'and animation property \'background-origin\'');
    });
}, 'Test processing of keyframes add property \'cssFloat\' to keyframe result as \'float\'. ' +
    'Input is a sequence of objects');

// member value: the result of calling ToString on the value returned
// from the [[Get]] method of keyframe input with property name, name.
test(function() {
    var values = [
        {toString: 'not callable', valueOf: 'not callable'},
        {toString: returnsObject, valueOf: 'not callable'},
        {toString: 'not callable', valueOf: returnsObject},
        {toString: returnsObject, valueOf: returnsObject}
    ];
    values.forEach(function(value) {
        assert_throws('TypeError', function() {
             new KeyframeEffect({top: value});
        }, 'TypeError should be thrown for \'top\' value ' + value);
    });
}, 'Test KeyframeEffect constructor throws TypeError if supported property value ' +
    'can not be converted to string value. Input is a single object');

test(function() {
    var values = [
        {toString: 'not callable', valueOf: 'not callable'},
        {toString: returnsObject, valueOf: 'not callable'},
        {toString: 'not callable', valueOf: returnsObject},
        {toString: returnsObject, valueOf: returnsObject}
    ];
    values.forEach(function(value) {
        assert_throws('TypeError', function() {
             new KeyframeEffect().setFrames({top: value});
        }, 'TypeError should be thrown for \'top\' value ' + value);
    });
}, 'Test KeyframeEffect.setFrames() throws TypeError if supported property value ' +
    'can not be converted to string value. Input is a single object');

test(function() {
    var values = [
        {toString: 'not callable', valueOf: 'not callable'},
        {toString: returnsObject, valueOf: 'not callable'},
        {toString: 'not callable', valueOf: returnsObject},
        {toString: returnsObject, valueOf: returnsObject}
    ];
    values.forEach(function(value) {
        assert_throws('TypeError', function() {
             new KeyframeEffect([{top: value}, {top: value}]);
        }, 'TypeError should be thrown for \'top\' value ' + value);
    });
}, 'Test KeyframeEffect constructor throws TypeError if supported property value ' +
    'can not be converted to string value. Input is a sequence of objects');

test(function() {
    var values = [
        {toString: 'not callable', valueOf: 'not callable'},
        {toString: returnsObject, valueOf: 'not callable'},
        {toString: 'not callable', valueOf: returnsObject},
        {toString: returnsObject, valueOf: returnsObject}
    ];
    values.forEach(function(value) {
        assert_throws('TypeError', function() {
             new KeyframeEffect().setFrames([{top: value}, {top: value}]);
        }, 'TypeError should be thrown for \'top\' value ' + value);
    });
}, 'Test KeyframeEffect.setFrames() throws TypeError if supported property value ' +
    'can not be converted to string value. Input is a sequence of objects');


test(function() {
    var values = [
        true, false, 0.3, '10px',
        {toString: returnsStringX},
        {toString: returnsInt0_4},
        {toString: 'not callable', valueOf: returnsStringX},
        {toString: returnsObject, valueOf: returnsInt0_4}
    ];
    var expected = ['true', 'false', '0.3', '10px', 'X', '0.4', 'X','0.4'];
    values.forEach(function(value, index) {
        var effects = createEffectsToTest({top: value});
        var keyframes = [
            {top: expected[index], offset: null, easing: 'linear', composite: null, computedOffset: 0}
        ];
        effects.forEach(function(effect, index) {
            assert_array_equals(effect.getFrames(), keyframes,
                effectsDescription[index] + ' should set Keyframe attributes to default values ' +
                'and animation property \'top\'');
        });
    });
}, 'Test processing of keyframes converts supported properties values via calling ToString. '+
    'Input is a single object');

test(function() {
    var values = [
        true, false, 0.3, '10px',
        {toString: returnsStringX},
        {toString: returnsInt0_4},
        {toString: 'not callable', valueOf: returnsStringX},
        {toString: returnsObject, valueOf: returnsInt0_4}
    ];
    var expected = ['true', 'false', '0.3', '10px', 'X', '0.4', 'X','0.4'];
    values.forEach(function(value, index) {
        var effects = createEffectsToTest([{easing: value}, {easing: value}]);
        var keyframes = [
            {top: expected[index], offset: null, easing: 'linear', composite: null, computedOffset: 0},
            {top: expected[index], offset: null, easing: 'linear', composite: null, computedOffset: 1}
        ];
        effects.forEach(function(effect, index) {
            assert_array_equals(effect.getFrames(), keyframes,
                effectsDescription[index] + ' should set Keyframe attributes to default values ' +
                'and animation property \'top\'');
        });
    });
}, 'Test processing of keyframes converts supported properties values via calling ToString. '+
    'Input is a sequence of objects');

// If [[Get]] returns null or undefined, let the member value be an empty string.
test(function() {
    var effects = createEffectsToTest({top: null});
    var keyframes = [{top: '', offset: null, easing: 'linear', composite: null, computedOffset: 0}];
    effects.forEach(function(effect, index) {
        assert_array_equals(effect.getFrames(), keyframes,
            effectsDescription[index] + ' should set Keyframe attributes to default values ' +
            'and animation property \'top\'');
    });
}, 'Test processing of keyframes add empty string value for supported properties ' +
    'with null value to keyframe result. Input is a single object');

test(function() {
    var effects = createEffectsToTest([{top: null}, {top: null}]);
    var keyframes = [
        {top: '', offset: null, easing: 'linear', composite: null, computedOffset: 0},
        {top: '', offset: null, easing: 'linear', composite: null, computedOffset: 1}
    ];
    effects.forEach(function(effect, index) {
        assert_array_equals(effect.getFrames(), keyframes,
            effectsDescription[index] + ' should set Keyframe attributes to default values ' +
            'and animation property \'top\'');
    });
}, 'Test processing of keyframes add empty string value for supported properties ' +
    'with null value to keyframe result. Input is a sequence of objects');

test(function() {
    var effects = createEffectsToTest({top: undefined});
    var keyframes = [{top: '', offset: null, easing: 'linear', composite: null, computedOffset: 0}];
    effects.forEach(function(effect, index) {
        assert_array_equals(effect.getFrames(), keyframes,
            effectsDescription[index] + ' should set Keyframe attributes to default values ' +
            'and animation property \'top\'');
    });
}, 'Test processing of keyframes add empty string value for supported properties ' +
    'with undefined value to keyframe result. Input is a single object');

test(function() {
    var effects = createEffectsToTest([{top: undefined}, {top: undefined}]);
    var keyframes = [
        {top: '', offset: null, easing: 'linear', composite: null, computedOffset: 0},
        {top: '', offset: null, easing: 'linear', composite: null, computedOffset: 1}
    ];
    effects.forEach(function(effect, index) {
        assert_array_equals(effect.getFrames(), keyframes,
            effectsDescription[index] + ' should set Keyframe attributes to default values ' +
            'and animation property \'top\'');
    });
}, 'Test processing of keyframes add empty string value for supported properties ' +
    'with undefined value to keyframe result. Input is a sequence of objects');

//10. Return keyframe result.

</script>
</body>
