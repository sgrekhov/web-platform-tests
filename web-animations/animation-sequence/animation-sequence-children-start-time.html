<!DOCTYPE html>
<meta charset=utf-8>
<title>AnimationSequence child nodes start time test</title>
<meta name="assert" content="The start time of a child animation node of an animation sequence is the end time of the child's previous sibling. If the child has no previous sibling the start time is zero">
<link rel="help" href="dev.w3.org/fxtf/web-animations/#animation-sequences">
<link rel="author" title="Sergey G. Grekhov" href="mailto:sgrekhov@unipro.ru">
<link rel="author" title="Aleksei Yu. Semenov" href="mailto:a.semenov@unipro.ru">
<script src="/resources/testharness.js"></script>
<script src="/resources/testharnessreport.js"></script>
<script src="../testcommon.js"></script>
<link rel="stylesheet" href="/resources/testharness.css">
<body>
<div id="log"></div>
<script>
// First part If the child has no previous sibling the start time is zero

test(function() {
    var nodes = [newAnimation(createDiv(this)),
        new AnimationGroup([]),
        new AnimationSequence([])];
    nodes.forEach(function(node, index) {
        var animationSequence = new AnimationSequence([node]);
        assert_equals(node.computedTiming.startTime, 0, 'Node ' + index + ': The start ' +
            'time of the first child animation node of an animation sequence should be zero');
    });
}, 'Test AnimationSequence constructor sets start time to zero for first child');

test(function() {
    var nodes = [newAnimation(createDiv(this)),
        new AnimationGroup([]),
        new AnimationSequence([])];
    var animationSequence = new AnimationSequence([]);
    nodes.forEach(function(node, index) {
        animationSequence.prepend(node);
        assert_equals(node.computedTiming.startTime, 0, 'Node ' + index + ': The start ' +
            'time of the first child animation node of an animation sequence should be zero');
    });
}, 'Test AnimationSequence.prepend sets start time to zero for first child');

test(function() {
    var nodes = [newAnimation(createDiv(this)),
         new AnimationGroup([]),
         new AnimationSequence([])];
    nodes.forEach(function(node, index) {
        var animationSequence = new AnimationSequence([]);
        animationSequence.append(node);
        assert_equals(node.computedTiming.startTime, 0, 'Node ' + index + ': The start ' +
            'time of the first child animation node of an animation sequence should be zero');
    });
}, 'Test AnimationSequence.append sets start time to zero for first child');

test(function() {
    var nodes = [newAnimation(createDiv(this)),
         new AnimationGroup([]),
         new AnimationSequence([])];
    var firstChild = newAnimation(createDiv(this));
    var animationSequence = new AnimationSequence([firstChild]);
    nodes.forEach(function(node, index) {
        firstChild.before(node);
        assert_equals(node.computedTiming.startTime, 0, 'Node ' + index + ': The start ' +
            'time of the first child animation node of an animation sequence should be zero');
        firstChild = node;
    });
}, 'Test AnimationNode.before sets start time to zero for first child');

test(function() {
    var nodes = [newAnimation(createDiv(this)),
        new AnimationGroup([]),
        new AnimationSequence([])];
    var firstChild = newAnimation(createDiv(this));
    var animationSequence = new AnimationSequence([firstChild]);
    nodes.forEach(function(node, index) {
        firstChild.replace(node);
        assert_equals(node.computedTiming.startTime, 0, 'Node ' + index + ': The start ' +
            'time of the first child animation node of an animation sequence should be zero');
        firstChild = node;
    });
}, 'Test AnimationNode.replace sets start time to zero for first child');

test(function() {
    var nodes = [newAnimation(createDiv(this)),
        newAnimation(createPseudoElement(this)),
        new AnimationGroup([]),
        new AnimationSequence([])];
    var animationSequence = new AnimationSequence(nodes);
    nodes.forEach(function(node, index) {
        assert_equals(node.computedTiming.startTime, 0, 'Node ' + index + ': The start ' +
            'time of the first child animation node of an animation sequence should be zero');
        node.remove();
    });
}, 'Test AnimationNode.remove sets start time to zero for first child');

// Second part The start time of a child animation node of an animation sequence is the end time of the child's previous sibling.

// Checks computed start time for each child of given animation sequence
function checkAnimationSequenceChildrenStartTimes(animationSequence) {
    var startTime = 0;
    animationSequence.children.forEach(function(node, index){
        assert_equals(node.computedTiming.startTime, startTime, 'Node ' + index +
            ': The start time of the animation node should be the end time of its ' +
            'previous sibling or zero if there is no previous sibling');
        startTime = node.computedTiming.endTime;
    });
}

test(function() {
    var node1 = newAnimation(createDiv(this));
    var node2 = newAnimation(createPseudoElement(this));
    var node3 = newAnimation(createDiv(this));
    var node4 = newAnimation(createPseudoElement(this));
    var node5 = new AnimationGroup([node1, node2]);
    var node6 = new AnimationSequence([node3]);
    var node7 = newAnimation(createDiv(this));
    var animationSequence = new AnimationSequence([node4, node5, node6, node7]);
    var player = document.timeline.play(animationSequence);

    checkAnimationSequenceChildrenStartTimes(animationSequence);
}, 'Test AnimationSequence constructor sets start time to the end time of ' +
    'the child\'s previous sibling for children after first one');

test(function() {
    var nodes = [newAnimation(createDiv(this)),
        new AnimationGroup([]),
        new AnimationSequence([])];
    nodes.forEach(function(node1, index) {
        var animationSequence = new AnimationSequence([node1]);
        var node2 = newAnimation(createDiv(this));
        animationSequence.prepend(node2);
        assert_equals(node1.computedTiming.startTime, node2.computedTiming.endTime,
            'Node ' + index + ': The start time of the animation node should be ' +
            'the end time of its previous sibling');
    });
}, 'Test AnimationSequence.prepend sets start time to the end time of the child\'s ' +
    'previous sibling for children after first one');

test(function() {
    var nodes = [newAnimation(createDiv(this)),
        newAnimation(createPseudoElement(this)),
        new AnimationGroup([]),
        new AnimationSequence([])];
    var animationSequence = new AnimationSequence();
    animationSequence.prepend(nodes);
    checkAnimationSequenceChildrenStartTimes(animationSequence);
}, 'Test AnimationSequence.prepend with several arguments sets start time to ' +
    'the end time of the child\'s previous sibling for children after first one');

test(function() {
    var nodes = [newAnimation(createDiv(this)),
        new AnimationGroup([]),
        new AnimationSequence([])];
    var prevNode = newAnimation(createDiv(this));
    var animationSequence = new AnimationSequence([prevNode]);
    nodes.forEach(function(node, index) {
        animationSequence.append(node);
        assert_equals(node.computedTiming.startTime, prevNode.computedTiming.endTime,
            'Node ' + index + ': The start time of the animation node should be ' +
            'the end time of its previous sibling');
        prevNode = node;
    });
}, 'Test AnimationSequence.append sets start time to the end time of the child\'s ' +
    'previous sibling for children after first one');

test(function() {
    var nodes = [newAnimation(createDiv(this)),
        new AnimationGroup([]),
        new AnimationSequence([])];
    var prevNode = newAnimation(createDiv(this));
    var animationSequence = new AnimationSequence([prevNode]);
    animationSequence.append(nodes);
    checkAnimationSequenceChildrenStartTimes(animationSequence);
}, 'Test AnimationSequence.append with several arguments sets start time to ' +
    'the end time of the child\'s previous sibling for children after first one');

test(function() {
    var nodes = [newAnimation(createDiv(this)),
        new AnimationGroup([]),
        new AnimationGroup([]),
        newAnimation(createPseudoElement(this)),
        new AnimationSequence([]),
        new AnimationSequence([]),
        new AnimationGroup([]),
        new AnimationSequence([]),
        newAnimation(createDiv(this))];
    var prevNode = newAnimation(createDiv(this));
    var nextNode = newAnimation(createDiv(this));
    var animationSequence = new AnimationSequence([prevNode,nextNode]);
    nodes.forEach(function(node) {
        nextNode.before(node);
        nextNode = node;
        checkAnimationSequenceChildrenStartTimes(animationSequence);
    });
}, 'Test AnimationNode.before sets start time to the end time of the child\'s ' +
    'previous sibling for children after first one');

test(function() {
    var nodes = [newAnimation(createDiv(this)),
        new AnimationGroup([]),
        new AnimationGroup([]),
        newAnimation(createPseudoElement(this)),
        new AnimationSequence([]),
        new AnimationSequence([]),
        new AnimationGroup([]),
        new AnimationSequence([]),
        newAnimation(createDiv(this))];
    var prevNode = newAnimation(createDiv(this));
    var nextNode = newAnimation(createDiv(this));
    var animationSequence = new AnimationSequence([prevNode,nextNode]);
    nextNode.before(nodes);
    checkAnimationSequenceChildrenStartTimes(animationSequence);
}, 'Test AnimationNode.before with several arguments sets start time to the end ' +
    'time of the child\'s previous sibling for children after first one');

test(function() {
    var nodes = [newAnimation(createDiv(this)),
        new AnimationGroup([]),
        new AnimationGroup([]),
        newAnimation(createPseudoElement(this)),
        new AnimationSequence([]),
        new AnimationSequence([]),
        new AnimationGroup([]),
        new AnimationSequence([]),
        newAnimation(createDiv(this))];
    var prevNode = newAnimation(createDiv(this));
    var nextNode = newAnimation(createDiv(this));
    var animationSequence = new AnimationSequence([prevNode,nextNode]);
    nodes.forEach(function(node) {
        prevNode.after(node);
        nextNode = node;
        checkAnimationSequenceChildrenStartTimes(animationSequence);
    });
}, 'Test AnimationNode.after sets start time to the end time of the child\'s ' +
    'previous sibling for children after first one');

test(function() {
    var nodes = [newAnimation(createDiv(this)),
        new AnimationGroup([]),
        new AnimationGroup([]),
        newAnimation(createPseudoElement(this)),
        new AnimationSequence([]),
        new AnimationSequence([]),
        new AnimationGroup([]),
        new AnimationSequence([]),
        newAnimation(createDiv(this))];
    var prevNode = newAnimation(createDiv(this));
    var nextNode = newAnimation(createDiv(this));
    var animationSequence = new AnimationSequence([prevNode,nextNode]);
    prevNode.after(nodes);
    checkAnimationSequenceChildrenStartTimes(animationSequence);
}, 'Test AnimationNode.after with several arguments sets start time to the end ' +
    'time of the child\'s previous sibling for children after first one');

test(function() {
    var nodes = [newAnimation(createDiv(this)),
        new AnimationGroup([]),
        new AnimationGroup([]),
        newAnimation(createPseudoElement(this)),
        new AnimationSequence([]),
        new AnimationSequence([]),
        new AnimationGroup([]),
        new AnimationSequence([]),
        newAnimation(createDiv(this))];
    var prevNode = newAnimation(createDiv(this));
    var nextNode = newAnimation(createDiv(this));
    var middleNode = newAnimation(createDiv(this));
    var animationSequence = new AnimationSequence([prevNode, middleNode, nextNode]);
    nodes.forEach(function(node, index) {
        middleNode.replace(node);
        assert_equals(node.computedTiming.startTime, prevNode.computedTiming.endTime,
            'Node ' + index + ': The start time of the animation node should be ' +
            'the end time of its previous sibling');
        assert_equals(nextNode.computedTiming.startTime, node.computedTiming.endTime,
            'Node ' + index + ': The start time of the animation node should be ' +
            'the end time of its previous sibling');
        middleNode = node;
    });
}, 'Test AnimationNode.replace sets start time to the end time of the child\'s ' +
    'previous sibling for children after first one');

test(function() {
    var nodes = [newAnimation(createDiv(this)),
        new AnimationGroup([]),
        new AnimationGroup([]),
        newAnimation(createPseudoElement(this)),
        new AnimationSequence([]),
        new AnimationSequence([]),
        new AnimationGroup([]),
        new AnimationSequence([]),
        newAnimation(createDiv(this))];
    var prevNode = newAnimation(createDiv(this));
    var nextNode = newAnimation(createDiv(this));
    var middleNode = newAnimation(createDiv(this));
    var animationSequence = new AnimationSequence([prevNode, middleNode, nextNode]);
    middleNode.replace(nodes);
    checkAnimationSequenceChildrenStartTimes(animationSequence);
}, 'Test AnimationNode.replace with several arguments sets start time to the end ' +
    'time of the child\'s previous sibling for children after first one');

test(function() {
    var nodes = [newAnimation(createDiv(this)),
        new AnimationGroup([]),
        new AnimationGroup([]),
        newAnimation(createPseudoElement(this)),
        new AnimationSequence([]),
        new AnimationSequence([]),
        new AnimationGroup([]),
        new AnimationSequence([]),
        newAnimation(createDiv(this))];
    var prevNode = newAnimation(createDiv(this));
    var nextNode = newAnimation(createDiv(this));
    var animationSequence = new AnimationSequence([].concat(prevNode, nodes, nextNode));
    nodes.forEach(function(node) {
        node.remove();
        checkAnimationSequenceChildrenStartTimes(animationSequence);
    });
}, 'Test AnimationNode.remove sets start time to the end time of the child\'s ' +
    'previous sibling for children after first one');
</script>
</body>
