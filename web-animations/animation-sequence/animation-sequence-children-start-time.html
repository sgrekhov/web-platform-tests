<!DOCTYPE html>
<meta charset=utf-8>
<title>AnimationSequence child nodes start time test</title>
<meta name="assert" content="The start time of a child animation node of an animation sequence is the end time of the child's previous sibling. If the child has no previous sibling the start time is zero">
<link rel="help" href="dev.w3.org/fxtf/web-animations/#animation-sequences">
<link rel="author" title="Sergey G. Grekhov" href="mailto:sgrekhov@unipro.ru">
<link rel="author" title="Aleksei Yu. Semenov" href="mailto:a.semenov@unipro.ru">
<script src="/resources/testharness.js"></script>
<script src="/resources/testharnessreport.js"></script>
<script src="../testcommon.js"></script>
<link rel="stylesheet" href="/resources/testharness.css">
<body>
<div id="log"></div>
<script>
// First part If the child has no previous sibling the start time is zero
test(function() {
    var nodes = [
        new Animation(createDiv(this), KEYFRAMES, ANIMATION_DURATION),
        new AnimationGroup([]),
        new AnimationSequence([])
    ];
    nodes.forEach(function(node) {
        var animationSequence = new AnimationSequence([node]);
        assert_equals(node.computedTiming.startTime, 0, 'Animation sequence first ' +
            'child of type ' + type(node) + ' should have startTime attribute equal to zero');
    });
}, 'Test AnimationSequence constructor sets start time to zero for first child');

test(function() {
    var nodes = [
        new Animation(createDiv(this), KEYFRAMES, ANIMATION_DURATION),
        new AnimationGroup([]),
        new AnimationSequence([])
    ];
    var animationSequence = new AnimationSequence([]);
    nodes.forEach(function(node) {
        animationSequence.prepend(node);
        assert_equals(node.computedTiming.startTime, 0, 'Animation sequence first ' +
            'child of type ' + type(node) + ' should have startTime attribute equal to zero');
    });
}, 'Test AnimationSequence.prepend sets start time to zero for first child');

test(function() {
    var nodes = [
         new Animation(createDiv(this), KEYFRAMES, ANIMATION_DURATION),
         new AnimationGroup([]),
         new AnimationSequence([])
    ];
    nodes.forEach(function(node) {
        var animationSequence = new AnimationSequence([]);
        animationSequence.append(node);
        assert_equals(node.computedTiming.startTime, 0, 'Animation sequence first ' +
            'child of type ' + type(node) + ' should have startTime attribute equal to zero');
    });
}, 'Test AnimationSequence.append sets start time to zero for first child');

test(function() {
    var nodes = [
         new Animation(createDiv(this), KEYFRAMES, ANIMATION_DURATION),
         new AnimationGroup([]),
         new AnimationSequence([])
    ];
    var firstChild = new Animation(createDiv(this), KEYFRAMES, ANIMATION_DURATION);
    var animationSequence = new AnimationSequence([firstChild]);
    nodes.forEach(function(node) {
        firstChild.before(node);
        assert_equals(node.computedTiming.startTime, 0, 'Animation sequence first ' +
            'child of type ' + type(node) + ' should have startTime attribute equal to zero');
        firstChild = node;
    });
}, 'Test AnimationNode.before sets start time to zero for first child');

test(function() {
    var nodes = [
        new Animation(createDiv(this), KEYFRAMES, ANIMATION_DURATION),
        new AnimationGroup([]),
        new AnimationSequence([])
    ];
    var firstChild = new Animation(createDiv(this), KEYFRAMES, ANIMATION_DURATION);
    var animationSequence = new AnimationSequence([firstChild]);
    nodes.forEach(function(node) {
        firstChild.replace(node);
        assert_equals(node.computedTiming.startTime, 0, 'Animation sequence first ' +
            'child of type ' + type(node) + ' should have startTime attribute equal to zero');
        firstChild = node;
    });
}, 'Test AnimationNode.replace sets start time to zero for first child');

test(function() {
    var nodes = [
        new Animation(createDiv(this), KEYFRAMES, ANIMATION_DURATION),
        new Animation(createPseudoElement(this), KEYFRAMES, ANIMATION_DURATION),
        new AnimationGroup([]),
        new AnimationSequence([])];
    var animationSequence = new AnimationSequence(nodes);
    nodes.forEach(function(node) {
        assert_equals(node.computedTiming.startTime, 0, 'Animation sequence first ' +
            'child of type ' + type(node) + ' should have startTime attribute equal to zero');
        node.remove();
    });
}, 'Test AnimationNode.remove sets start time to zero for first child');

// Second part The start time of a child animation node of an animation sequence is the end time of the child's previous sibling.

// Checks computed start time for each child of given animation sequence
function checkAnimationSequenceChildrenStartTimes(animationSequence) {
    var startTime = 0;
    for (var i = 0; i < animationSequence.children.length; i++) {
        assert_equals(animationSequence.children[i].computedTiming.startTime, startTime,
            'The start time of the animation node #' + i + ' of type ' +
            type(animationSequence.children[i]) + ' should be the end time of its previous ' +
            'sibling or zero if there is no previous sibling');
        startTime = animationSequence.children[i].computedTiming.endTime;
    }
}

test(function() {
    var node1 = new Animation(createDiv(this), KEYFRAMES, ANIMATION_DURATION);
    var node2 = new Animation(createPseudoElement(this), KEYFRAMES, ANIMATION_DURATION);
    var node3 = new Animation(createDiv(this), KEYFRAMES, ANIMATION_DURATION);
    var node4 = new Animation(createPseudoElement(this), KEYFRAMES, ANIMATION_DURATION);
    var node5 = new AnimationGroup([node1, node2]);
    var node6 = new AnimationSequence([node3]);
    var node7 = new Animation(createDiv(this), KEYFRAMES, ANIMATION_DURATION);
    var animationSequence = new AnimationSequence([node4, node5, node6, node7]);
    var player = document.timeline.play(animationSequence);

    checkAnimationSequenceChildrenStartTimes(animationSequence);
}, 'Test AnimationSequence constructor sets start time to the end time of ' +
    'the child\'s previous sibling for children after first one');

test(function() {
    var nodes = [
        new Animation(createDiv(this), KEYFRAMES, ANIMATION_DURATION),
        new AnimationGroup([]),
        new AnimationSequence([])
    ];
    nodes.forEach(function(node1, index) {
        var animationSequence = new AnimationSequence([node1]);
        var node2 = new Animation(createDiv(this), KEYFRAMES, ANIMATION_DURATION);
        animationSequence.prepend(node2);
        assert_equals(node1.computedTiming.startTime, node2.computedTiming.endTime,
            'The start time of the animation node #' + index + ' of type ' + type(node1) +
            ' should be the end time of its previous sibling');
    });
}, 'Test AnimationSequence.prepend sets start time to the end time of the child\'s ' +
    'previous sibling for children after first one');

test(function() {
    var nodes = [
        new Animation(createDiv(this), KEYFRAMES, ANIMATION_DURATION),
        new Animation(createPseudoElement(this), KEYFRAMES, ANIMATION_DURATION),
        new AnimationGroup([]),
        new AnimationSequence([])
    ];
    var animationSequence = new AnimationSequence();
    animationSequence.prepend(nodes);
    checkAnimationSequenceChildrenStartTimes(animationSequence);
}, 'Test AnimationSequence.prepend with several arguments sets start time to ' +
    'the end time of the child\'s previous sibling for children after first one');

test(function() {
    var nodes = [
        new Animation(createDiv(this), KEYFRAMES, ANIMATION_DURATION),
        new AnimationGroup([]),
        new AnimationSequence([])
    ];
    var prevNode = new Animation(createDiv(this), KEYFRAMES, ANIMATION_DURATION);
    var animationSequence = new AnimationSequence([prevNode]);
    nodes.forEach(function(node, index) {
        animationSequence.append(node);
        assert_equals(node.computedTiming.startTime, prevNode.computedTiming.endTime,
            'The start time of the animation node #' + index + ' of type ' + type(node) +
            ' should be the end time of its previous sibling');
        prevNode = node;
    });
}, 'Test AnimationSequence.append sets start time to the end time of the child\'s ' +
    'previous sibling for children after first one');

test(function() {
    var nodes = [
        new Animation(createDiv(this), KEYFRAMES, ANIMATION_DURATION),
        new AnimationGroup([]),
        new AnimationSequence([])
    ];
    var prevNode = new Animation(createDiv(this), KEYFRAMES, ANIMATION_DURATION);
    var animationSequence = new AnimationSequence([prevNode]);
    animationSequence.append(nodes);
    checkAnimationSequenceChildrenStartTimes(animationSequence);
}, 'Test AnimationSequence.append with several arguments sets start time to ' +
    'the end time of the child\'s previous sibling for children after first one');

test(function() {
    var nodes = [
        new Animation(createDiv(this), KEYFRAMES, ANIMATION_DURATION),
        new AnimationGroup([]),
        new AnimationGroup([]),
        new Animation(createPseudoElement(this), KEYFRAMES, ANIMATION_DURATION),
        new AnimationSequence([]),
        new AnimationSequence([]),
        new AnimationGroup([]),
        new AnimationSequence([]),
        new Animation(createDiv(this), KEYFRAMES, ANIMATION_DURATION)
    ];
    var prevNode = new Animation(createDiv(this), KEYFRAMES, ANIMATION_DURATION);
    var nextNode = new Animation(createDiv(this), KEYFRAMES, ANIMATION_DURATION);
    var animationSequence = new AnimationSequence([prevNode,nextNode]);
    nodes.forEach(function(node) {
        nextNode.before(node);
        nextNode = node;
        checkAnimationSequenceChildrenStartTimes(animationSequence);
    });
}, 'Test AnimationNode.before sets start time to the end time of the child\'s ' +
    'previous sibling for children after first one');

test(function() {
    var nodes = [
        new Animation(createDiv(this), KEYFRAMES, ANIMATION_DURATION),
        new AnimationGroup([]),
        new AnimationGroup([]),
        new Animation(createPseudoElement(this), KEYFRAMES, ANIMATION_DURATION),
        new AnimationSequence([]),
        new AnimationSequence([]),
        new AnimationGroup([]),
        new AnimationSequence([]),
        new Animation(createDiv(this), KEYFRAMES, ANIMATION_DURATION)
    ];
    var prevNode = new Animation(createDiv(this), KEYFRAMES, ANIMATION_DURATION);
    var nextNode = new Animation(createDiv(this), KEYFRAMES, ANIMATION_DURATION);
    var animationSequence = new AnimationSequence([prevNode,nextNode]);
    nextNode.before(nodes);
    checkAnimationSequenceChildrenStartTimes(animationSequence);
}, 'Test AnimationNode.before with several arguments sets start time to the end ' +
    'time of the child\'s previous sibling for children after first one');

test(function() {
    var nodes = [
        new Animation(createDiv(this), KEYFRAMES, ANIMATION_DURATION),
        new AnimationGroup([]),
        new AnimationGroup([]),
        new Animation(createPseudoElement(this), KEYFRAMES, ANIMATION_DURATION),
        new AnimationSequence([]),
        new AnimationSequence([]),
        new AnimationGroup([]),
        new AnimationSequence([]),
        new Animation(createDiv(this), KEYFRAMES, ANIMATION_DURATION)
    ];
    var prevNode = new Animation(createDiv(this), KEYFRAMES, ANIMATION_DURATION);
    var nextNode = new Animation(createDiv(this), KEYFRAMES, ANIMATION_DURATION);
    var animationSequence = new AnimationSequence([prevNode,nextNode]);
    nodes.forEach(function(node) {
        prevNode.after(node);
        nextNode = node;
        checkAnimationSequenceChildrenStartTimes(animationSequence);
    });
}, 'Test AnimationNode.after sets start time to the end time of the child\'s ' +
    'previous sibling for children after first one');

test(function() {
    var nodes = [
        new Animation(createDiv(this), KEYFRAMES, ANIMATION_DURATION),
        new AnimationGroup([]),
        new AnimationGroup([]),
        new Animation(createPseudoElement(this), KEYFRAMES, ANIMATION_DURATION),
        new AnimationSequence([]),
        new AnimationSequence([]),
        new AnimationGroup([]),
        new AnimationSequence([]),
        new Animation(createDiv(this), KEYFRAMES, ANIMATION_DURATION)
    ];
    var prevNode = new Animation(createDiv(this), KEYFRAMES, ANIMATION_DURATION);
    var nextNode = new Animation(createDiv(this), KEYFRAMES, ANIMATION_DURATION);
    var animationSequence = new AnimationSequence([prevNode,nextNode]);
    prevNode.after(nodes);
    checkAnimationSequenceChildrenStartTimes(animationSequence);
}, 'Test AnimationNode.after with several arguments sets start time to the end ' +
    'time of the child\'s previous sibling for children after first one');

test(function() {
    var nodes = [
        new Animation(createDiv(this), KEYFRAMES, ANIMATION_DURATION),
        new AnimationGroup([]),
        new AnimationGroup([]),
        new Animation(createPseudoElement(this), KEYFRAMES, ANIMATION_DURATION),
        new AnimationSequence([]),
        new AnimationSequence([]),
        new AnimationGroup([]),
        new AnimationSequence([]),
        new Animation(createDiv(this), KEYFRAMES, ANIMATION_DURATION)
    ];
    var prevNode = new Animation(createDiv(this), KEYFRAMES, ANIMATION_DURATION);
    var nextNode = new Animation(createDiv(this), KEYFRAMES, ANIMATION_DURATION);
    var middleNode = new Animation(createDiv(this), KEYFRAMES, ANIMATION_DURATION);
    var animationSequence = new AnimationSequence([prevNode, middleNode, nextNode]);
    nodes.forEach(function(node, index) {
        middleNode.replace(node);
        assert_equals(node.computedTiming.startTime, prevNode.computedTiming.endTime,
            'The start time of the animation node #' + index + ' of type ' + type(node) +
            ' should be the end time of its previous sibling');
        assert_equals(nextNode.computedTiming.startTime, node.computedTiming.endTime,
            'The start time of the animation node #' + (index + 1) + ' of type ' +
            type(nextNode) + ' should be the end time of its previous sibling');
        middleNode = node;
    });
}, 'Test AnimationNode.replace sets start time to the end time of the child\'s ' +
    'previous sibling for children after first one');

test(function() {
    var nodes = [
        new Animation(createDiv(this), KEYFRAMES, ANIMATION_DURATION),
        new AnimationGroup([]),
        new AnimationGroup([]),
        new Animation(createPseudoElement(this), KEYFRAMES, ANIMATION_DURATION),
        new AnimationSequence([]),
        new AnimationSequence([]),
        new AnimationGroup([]),
        new AnimationSequence([]),
        new Animation(createDiv(this), KEYFRAMES, ANIMATION_DURATION)
    ];
    var prevNode = new Animation(createDiv(this), KEYFRAMES, ANIMATION_DURATION);
    var nextNode = new Animation(createDiv(this), KEYFRAMES, ANIMATION_DURATION);
    var middleNode = new Animation(createDiv(this), KEYFRAMES, ANIMATION_DURATION);
    var animationSequence = new AnimationSequence([prevNode, middleNode, nextNode]);
    middleNode.replace(nodes);
    checkAnimationSequenceChildrenStartTimes(animationSequence);
}, 'Test AnimationNode.replace with several arguments sets start time to the end ' +
    'time of the child\'s previous sibling for children after first one');

test(function() {
    var nodes = [
        new Animation(createDiv(this), KEYFRAMES, ANIMATION_DURATION),
        new AnimationGroup([]),
        new AnimationGroup([]),
        new Animation(createPseudoElement(this), KEYFRAMES, ANIMATION_DURATION),
        new AnimationSequence([]),
        new AnimationSequence([]),
        new AnimationGroup([]),
        new AnimationSequence([]),
        new Animation(createDiv(this), KEYFRAMES, ANIMATION_DURATION)
    ];
    var prevNode = new Animation(createDiv(this), KEYFRAMES, ANIMATION_DURATION);
    var nextNode = new Animation(createDiv(this), KEYFRAMES, ANIMATION_DURATION);
    var animationSequence = new AnimationSequence([].concat(prevNode, nodes, nextNode));
    nodes.forEach(function(node) {
        node.remove();
        checkAnimationSequenceChildrenStartTimes(animationSequence);
    });
}, 'Test AnimationNode.remove sets start time to the end time of the child\'s ' +
    'previous sibling for children after first one');
</script>
</body>
