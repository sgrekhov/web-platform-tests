<!DOCTYPE html>
<meta charset=utf-8>
<title>AnimationTiming easing attribute test</title>
<meta name="assert" content="The timing function used to scale the time to produce easing effects">
<link rel="help" href="http://w3c.github.io/web-animations/#dom-animationtiming-easing">
<link rel="author" title="Sergey G. Grekhov" href="mailto:sgrekhov@unipro.ru">
<script src="/resources/testharness.js"></script>
<script src="/resources/testharnessreport.js"></script>
<script src="../testcommon.js"></script>
<link rel="stylesheet" href="/resources/testharness.css">
<body>
<div id="log"></div>
<script>
function createAnimationsToTest(test, timing) {
    var animation1 = new Animation(createDiv(test), KEYFRAMES, timing);
    var animation2 = new Animation(createDiv(test), KEYFRAMES, ANIMATION_DURATION);
    var animation3 = new Animation(createDiv(test), KEYFRAMES, ANIMATION_DURATION);
    var animationGroup = new AnimationGroup([animation2], timing);
    var animationSequence = new AnimationSequence([animation3], timing);
    return [animation1, animation2, animation3];
}

function testLinearEasing(player, animation, node) {
	player.currentTime = 1;
    assert_approx_equals(window.getComputedStyle(animation.target).top,
        getExpectedTop(player.currentTime), COMPUTED_STYLE_EPSILON,
        'Wrong effect for node ' + type(node) + ' at time ' + player.currentTime);

    player.currentTime = ANIMATION_DURATION / 4;
    assert_approx_equals(window.getComputedStyle(animation.target).top,
        getExpectedTop(player.currentTime), COMPUTED_STYLE_EPSILON,
        'Wrong effect for node ' + type(node) + ' at time ' + player.currentTime);

    player.currentTime = ANIMATION_DURATION / 2;
    assert_approx_equals(window.getComputedStyle(animation.target).top,
        getExpectedTop(player.currentTime), COMPUTED_STYLE_EPSILON,
        'Wrong effect for node ' + type(node) + ' at time ' + player.currentTime);

    player.currentTime = ANIMATION_DURATION * 3 / 4;
    assert_approx_equals(window.getComputedStyle(animation.target).top,
        getExpectedTop(player.currentTime), COMPUTED_STYLE_EPSILON,
        'Wrong effect for node ' + type(node) + ' at time ' + player.currentTime);

    player.currentTime = ANIMATION_DURATION - 1;
    assert_approx_equals(window.getComputedStyle(animation.target).top,
        getExpectedTop(player.currentTime), COMPUTED_STYLE_EPSILON,
        'Wrong effect for node ' + type(node) + ' at time ' + player.currentTime);
}

function testBezierEasing(player, animation, node, p1x, p1y, p2x, p2y) {
	player.currentTime = 1;
	var transformedTime = bezierCurve(player.currentTime / ANIMATION_DURATION,
        p1x, p1y, p2x, p2y) * ANIMATION_DURATION;
    assert_approx_equals(window.getComputedStyle(animation.target).top,
        getExpectedTop(transformedTime), COMPUTED_STYLE_EPSILON,
        'Wrong effect for node ' + type(node) + ' at time ' + player.currentTime);

    player.currentTime = ANIMATION_DURATION / 4;
    var transformedTime = bezierCurve(player.currentTime / ANIMATION_DURATION,
        p1x, p1y, p2x, p2y) * ANIMATION_DURATION;
    assert_approx_equals(window.getComputedStyle(animation.target).top,
        getExpectedTop(transformedTime), COMPUTED_STYLE_EPSILON,
        'Wrong effect for node ' + type(node) + ' at time ' + player.currentTime);

    player.currentTime = ANIMATION_DURATION / 2;
    var transformedTime = bezierCurve(player.currentTime / ANIMATION_DURATION,
        p1x, p1y, p2x, p2y) * ANIMATION_DURATION;
    assert_approx_equals(window.getComputedStyle(animation.target).top,
        getExpectedTop(transformedTime), COMPUTED_STYLE_EPSILON,
        'Wrong effect for node ' + type(node) + ' at time ' + player.currentTime);

    player.currentTime = ANIMATION_DURATION * 3 / 4;
    var transformedTime = bezierCurve(player.currentTime / ANIMATION_DURATION,
        p1x, p1y, p2x, p2y) * ANIMATION_DURATION;
    assert_approx_equals(window.getComputedStyle(animation.target).top,
        getExpectedTop(transformedTime), COMPUTED_STYLE_EPSILON,
        'Wrong effect for node ' + type(node) + ' at time ' + player.currentTime);

    player.currentTime = ANIMATION_DURATION - 1;
    var transformedTime = bezierCurve(player.currentTime / ANIMATION_DURATION,
        p1x, p1y, p2x, p2y) * ANIMATION_DURATION;
    assert_approx_equals(window.getComputedStyle(animation.target).top,
        getExpectedTop(transformedTime), COMPUTED_STYLE_EPSILON,
        'Wrong effect for node ' + type(node) + ' at time ' + player.currentTime);
}

function bezierCurve(x, p1x, p1y, p2x, p2y) {
	// FIXME this is a stub for the function that should return
	// cubic bezier curve y value for x value and p1 and p2 points
    return 0;
}

async_test(function(t) {
    var timing = {
        duration: ANIMATION_DURATION
    };
    var animations = createAnimationsToTest(t, timing);
    var doneCounter = 0;
    animations.forEach(function(animation) {
        var node = animation;
        if (animation.parent !== null) {
            node = node.parent;
        }
        var player = document.timeline.play(node);
        assert_equals(node.computedTiming.easing, 'linear',
            'Wrong AnimationNode.computedTiming.easing value');

        player.ready.then(t.step_func(function() {
            testLinearEasing(player, animation, node);
            doneCounter++;
            if (doneCounter === animations.length) {
                t.done();
            }
        }), t.unreached_func('Current ready promise should not be rejected'));
    });
}, 'Test that default value of AnimationTiming.easing is \'linear\' ' +
    'and animations goes as linear');

async_test(function(t) {
    var timing = {
        duration: ANIMATION_DURATION,
        easing: 'linear'
    };
    var animations = createAnimationsToTest(t, timing);
    var doneCounter = 0;
    animations.forEach(function(animation) {
        var node = animation;
        if (animation.parent !== null) {
            node = node.parent;
        }
        var player = document.timeline.play(node);
        assert_equals(node.computedTiming.easing, 'linear',
            'Wrong AnimationNode.computedTiming.easing value');

        player.ready.then(t.step_func(function() {
            testLinearEasing(player, animation, node);
            doneCounter++;
            if (doneCounter === animations.length) {
                t.done();
            }
        }), t.unreached_func('Current ready promise should not be rejected'));
    });
}, 'Test that if value of AnimationTiming.easing is \'linear\' ' +
    'then animations goes as linear');

async_test(function(t) {
    var timing = {
        duration: ANIMATION_DURATION,
        easing: 'unsupported-value'
    };
    var animations = createAnimationsToTest(t, timing);
    var doneCounter = 0;
    animations.forEach(function(animation) {
        var node = animation;
        if (animation.parent !== null) {
            node = node.parent;
        }
        var player = document.timeline.play(node);
        assert_equals(node.computedTiming.easing, 'linear',
            'Wrong AnimationNode.computedTiming.easing value');

        player.ready.then(t.step_func(function() {
            testLinearEasing(player, animation, node);
            doneCounter++;
            if (doneCounter === animations.length) {
                t.done();
            }
        }), t.unreached_func('Current ready promise should not be rejected'));
    });
}, 'Test that unsupported value of AnimationTiming.easing is treated ' +
    'as \'linear\' and animations goes as linear');

async_test(function(t) {
    var timing = {
        duration: ANIMATION_DURATION,
        easing: 'cubic-bezier(2, 2, 3, 3)'
    };
    var animations = createAnimationsToTest(t, timing);
    var doneCounter = 0;
    animations.forEach(function(animation) {
        var node = animation;
        if (animation.parent !== null) {
            node = node.parent;
        }
        var player = document.timeline.play(node);
        assert_equals(node.computedTiming.easing, 'linear',
            'Wrong AnimationNode.computedTiming.easing value');

        player.ready.then(t.step_func(function() {
            testLinearEasing(player, animation, node);
            doneCounter++;
            if (doneCounter === animations.length) {
                t.done();
            }
        }), t.unreached_func('Current ready promise should not be rejected'));
    });
}, 'Test that invalid cubic bezier function as a value of AnimationTiming.easing is treated ' +
    'as \'linear\' and animations goes as linear');

async_test(function(t) {
    var timing = {
        duration: ANIMATION_DURATION,
        easing: 'ease'
    };
    var animations = createAnimationsToTest(t, timing);
    var doneCounter = 0;
    animations.forEach(function(animation) {
        var node = animation;
        if (animation.parent !== null) {
            node = node.parent;
        }
        var player = document.timeline.play(node);
        assert_equals(node.computedTiming.easing, 'ease',
            'Wrong AnimationNode.computedTiming.easing value');

        player.ready.then(t.step_func(function() {
            testBezierEasing(player, animation, node, 0.25, 0.1, 0.25, 1);
            doneCounter++;
            if (doneCounter === animations.length) {
                t.done();
            }
        }), t.unreached_func('Current ready promise should not be rejected'));
    });
}, 'Test that if value of AnimationTiming.easing is \'ease\' ' +
    'then animation goes as cubic-bezier(0.25, 0.1, 0.25, 1)');

async_test(function(t) {
    var timing = {
        duration: ANIMATION_DURATION,
        easing: 'ease-in'
    };
    var animations = createAnimationsToTest(t, timing);
    var doneCounter = 0;
    animations.forEach(function(animation) {
        var node = animation;
        if (animation.parent !== null) {
            node = node.parent;
        }
        var player = document.timeline.play(node);
        assert_equals(node.computedTiming.easing, 'ease-in',
            'Wrong AnimationNode.computedTiming.easing value');

        player.ready.then(t.step_func(function() {
            testBezierEasing(player, animation, node, 0.42, 0, 1, 1);
            doneCounter++;
            if (doneCounter === animations.length) {
                t.done();
            }
        }), t.unreached_func('Current ready promise should not be rejected'));
    });
}, 'Test that if value of AnimationTiming.easing is \'ease-in\' ' +
    'then animation goes as cubic-bezier(0.42, 0, 1, 1)');

async_test(function(t) {
    var timing = {
        duration: ANIMATION_DURATION,
        easing: 'ease-out'
    };
    var animations = createAnimationsToTest(t, timing);
    var doneCounter = 0;
    animations.forEach(function(animation) {
        var node = animation;
        if (animation.parent !== null) {
            node = node.parent;
        }
        var player = document.timeline.play(node);
        assert_equals(node.computedTiming.easing, 'ease-out',
            'Wrong AnimationNode.computedTiming.easing value');

        player.ready.then(t.step_func(function() {
            testBezierEasing(player, animation, node, 0, 0, 0.58, 1);
            doneCounter++;
            if (doneCounter === animations.length) {
                t.done();
            }
        }), t.unreached_func('Current ready promise should not be rejected'));
    });
}, 'Test that if value of AnimationTiming.easing is \'ease-out\' ' +
    'then animation goes as cubic-bezier(0, 0, 0.58, 1)');

async_test(function(t) {
    var timing = {
        duration: ANIMATION_DURATION,
        easing: 'ease-in-out'
    };
    var animations = createAnimationsToTest(t, timing);
    var doneCounter = 0;
    animations.forEach(function(animation) {
        var node = animation;
        if (animation.parent !== null) {
            node = node.parent;
        }
        var player = document.timeline.play(node);
        assert_equals(node.computedTiming.easing, 'ease-in-out',
            'Wrong AnimationNode.computedTiming.easing value');

        player.ready.then(t.step_func(function() {
            testBezierEasing(player, animation, node, 0.42, 0, 0.58, 1);
            doneCounter++;
            if (doneCounter === animations.length) {
                t.done();
            }
        }), t.unreached_func('Current ready promise should not be rejected'));
    });
}, 'Test that if value of AnimationTiming.easing is \'ease-in-out\' ' +
    'then animation goes as cubic-bezier(0.42, 0, 0.58, 1)');

async_test(function(t) {
    var timing = {
        duration: ANIMATION_DURATION,
        easing: 'cubic-bezier(0.4, 0, 0.6, 1)'
    };
    var animations = createAnimationsToTest(t, timing);
    var doneCounter = 0;
    animations.forEach(function(animation) {
        var node = animation;
        if (animation.parent !== null) {
            node = node.parent;
        }
        var player = document.timeline.play(node);
        assert_equals(node.computedTiming.easing, 'cubic-bezier(0.4, 0, 0.6, 1)',
            'Wrong AnimationNode.computedTiming.easing value');

        player.ready.then(t.step_func(function() {
            testBezierEasing(player, animation, node, 0.4, 0, 0.6, 1);
            doneCounter++;
            if (doneCounter === animations.length) {
                t.done();
            }
        }), t.unreached_func('Current ready promise should not be rejected'));
    });
}, 'Test that if value of AnimationTiming.easing is \'cubic-bezier(0.4, 0, 0.6, 1)\' ' +
    'then animation goes as cubic-bezier(0.4, 0, 0.6, 1)');

async_test(function(t) {
    var timing = {
        duration: ANIMATION_DURATION,
        easing: 'cubic-bezier(0.4, 2, 0.6, -1)'
    };
    var animations = createAnimationsToTest(t, timing);
    var doneCounter = 0;
    animations.forEach(function(animation) {
        var node = animation;
        if (animation.parent !== null) {
            node = node.parent;
        }
        var player = document.timeline.play(node);
        assert_equals(node.computedTiming.easing, 'cubic-bezier(0.4, 2, 0.6, -1)',
            'Wrong AnimationNode.computedTiming.easing value');

        player.ready.then(t.step_func(function() {
            testBezierEasing(player, animation, node, 0.4, 2, 0.6, -1);
            doneCounter++;
            if (doneCounter === animations.length) {
                t.done();
            }
        }), t.unreached_func('Current ready promise should not be rejected'));
    });
}, 'Test that if value of AnimationTiming.easing is \'cubic-bezier(0.4, 2, 0.6, -1)\' ' +
    'then animation goes as cubic-bezier(0.4, 2, 0.6, -1)');

async_test(function(t) {
    var timing = {
        duration: ANIMATION_DURATION,
        easing: 'cubic-bezier(0.4, 1000, 0.6, 500)'
    };
    var animations = createAnimationsToTest(t, timing);
    var doneCounter = 0;
    animations.forEach(function(animation) {
        var node = animation;
        if (animation.parent !== null) {
            node = node.parent;
        }
        var player = document.timeline.play(node);
        assert_equals(node.computedTiming.easing, 'cubic-bezier(0.4, 1000, 0.6, 500)',
            'Wrong AnimationNode.computedTiming.easing value');

        player.ready.then(t.step_func(function() {
            testBezierEasing(player, animation, node, 0.4, 1000, 0.6, 500);
            doneCounter++;
            if (doneCounter === animations.length) {
                t.done();
            }
        }), t.unreached_func('Current ready promise should not be rejected'));
    });
}, 'Test that if value of AnimationTiming.easing is \'cubic-bezier(0.4, 1000, 0.6, 500)\' ' +
    'then animation goes as cubic-bezier(0.4, 1000, 0.6, 500)');

async_test(function(t) {
    var timing = {
        duration: ANIMATION_DURATION,
        easing: 'step-start'
    };
    var animations = createAnimationsToTest(t, timing);
    var doneCounter = 0;
    animations.forEach(function(animation) {
        var node = animation;
        if (animation.parent !== null) {
            node = node.parent;
        }
        var player = document.timeline.play(node);
        assert_equals(node.computedTiming.easing, 'step-start',
            'Wrong AnimationNode.computedTiming.easing value');

        player.ready.then(t.step_func(function() {
            player.currentTime = 1;
            assert_equals(window.getComputedStyle(animation.target).top, ANIMATION_TOP_1,
                'Wrong effect for node ' + type(node) + ' at time ' + player.currentTime);

            player.currentTime = ANIMATION_DURATION / 2;
            assert_equals(window.getComputedStyle(animation.target).top, ANIMATION_TOP_1,
                'Wrong effect for node ' + type(node) + ' at time ' + player.currentTime);

            player.currentTime = ANIMATION_DURATION - 1;
            assert_equals(window.getComputedStyle(animation.target).top, ANIMATION_TOP_1,
                'Wrong effect for node ' + type(node) + ' at time ' + player.currentTime);
            doneCounter++;
            if (doneCounter === animations.length) {
                t.done();
            }
        }), t.unreached_func('Current ready promise should not be rejected'));
    });
}, 'Test that if value of AnimationTiming.easing is \'step-start\' ' +
    'then animation goes as steps(1, start)');

async_test(function(t) {
    var timing = {
        duration: ANIMATION_DURATION,
        easing: 'step-middle'
    };
    var animations = createAnimationsToTest(t, timing);
    var doneCounter = 0;
    animations.forEach(function(animation) {
        var node = animation;
        if (animation.parent !== null) {
            node = node.parent;
        }
        var player = document.timeline.play(node);
        assert_equals(node.computedTiming.easing, 'step-middle',
            'Wrong AnimationNode.computedTiming.easing value');

        player.ready.then(t.step_func(function() {
            player.currentTime = 1;
            assert_equals(window.getComputedStyle(animation.target).top, ANIMATION_TOP_0,
                'Wrong effect for node ' + type(node) + ' at time ' + player.currentTime);

            player.currentTime = ANIMATION_DURATION / 4;
            assert_equals(window.getComputedStyle(animation.target).top, ANIMATION_TOP_0,
                'Wrong effect for node ' + type(node) + ' at time ' + player.currentTime);

            player.currentTime = ANIMATION_DURATION / 2 - 1;
            assert_equals(window.getComputedStyle(animation.target).top, ANIMATION_TOP_0,
                'Wrong effect for node ' + type(node) + ' at time ' + player.currentTime);

            player.currentTime = ANIMATION_DURATION / 2;
            assert_equals(window.getComputedStyle(animation.target).top, ANIMATION_TOP_1,
                'Wrong effect for node ' + type(node) + ' at time ' + player.currentTime);

            player.currentTime = ANIMATION_DURATION * 3 / 4;
            assert_equals(window.getComputedStyle(animation.target).top, ANIMATION_TOP_1,
                'Wrong effect for node ' + type(node) + ' at time ' + player.currentTime);

            player.currentTime = ANIMATION_DURATION - 1;
            assert_equals(window.getComputedStyle(animation.target).top, ANIMATION_TOP_1,
                'Wrong effect for node ' + type(node) + ' at time ' + player.currentTime);
            doneCounter++;
            if (doneCounter === animations.length) {
                t.done();
            }
        }), t.unreached_func('Current ready promise should not be rejected'));
    });
}, 'Test that if value of AnimationTiming.easing is \'step-middle\' ' +
    'then animation goes as steps(1, middle)');
</script>
</body>
