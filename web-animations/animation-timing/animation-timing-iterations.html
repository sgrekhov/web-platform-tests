<!DOCTYPE html>
<meta charset=utf-8>
<title>AnimationTiming iterations attribute test</title>
<meta name="assert" content="The animation nodeâ€™s iteration count property. A real number greater than or equal to zero (including positive infinity) representing the number of times to repeat the animation node.">
<link rel="help" href="http://w3c.github.io/web-animations/#dom-animationtiming-iterationstart">
<link rel="author" title="Sergey G. Grekhov" href="mailto:sgrekhov@unipro.ru">
<script src="/resources/testharness.js"></script>
<script src="/resources/testharnessreport.js"></script>
<script src="../testcommon.js"></script>
<link rel="stylesheet" href="/resources/testharness.css">
<body>
<div id="log"></div>
<script>
function createAnimationsToTest(test, timing) {
    var animation1 = new Animation(createDiv(test), KEYFRAMES, timing);
    var animation2 = new Animation(createDiv(test), KEYFRAMES, ANIMATION_DURATION);
    var animation3 = new Animation(createDiv(test), KEYFRAMES, ANIMATION_DURATION);
    var animationGroup = new AnimationGroup([animation2], timing);
    var animationSequence = new AnimationSequence([animation3], timing);
    return [animation1, animation2, animation3];
}

async_test(function(t) {
    var valuesToTest = [-1, -1000, -0.5, -Number.MAX_VALUE, Number.NaN. -Infinity];
    var doneCounter = 0;
    valuesToTest.forEach(function(iterationsValue) {
        var timing = {
            iterations: iterationsValue,
            duration: ANIMATION_DURATION
        };
        var animations = createAnimationsToTest(t, timing);
        animations.forEach(function(animation) {
            var node = animation;
            if (animation.parent !== null) {
                node = node.parent;
            }
            var player = document.timeline.play(node);

            assert_equals(node.computedTiming.iterations, 1,
                'Wrong AnimationNode.computedTiming.iterations value');

            player.ready.then(t.step_func(function() {
                player.currentTime = ANIMATION_DURATION - 1;
                assert_approx_equals(window.getComputedStyle(animation.target), ANIMATION_TOP_1,
                    COMPUTED_STYLE_EPSILON, 'Animation ' + type(node) + ' should be close to ' +
                    'the end point');
                player.currentTime = ANIMATION_DURATION;
                assert_equals(window.getComputedStyle(animation.target), ANIMATION_TOP_DEFAULT,
                    'Animation ' + type(node) + ' should be finished');
                doneCounter++;
                if (doneCounter === animations.length * valuesToTest.length) {
                    t.done();
                }
            }), t.unreached_func('Current ready promise should not be rejected'));
        });
    });
}, 'Test that negative and NaN values of AnimationTiming.iterations attribute are treated ' +
    'as 1.0 for the purpose of timing model calculations');

async_test(function(t) {
    var timing = {
        iterations: 0.5,
        duration: ANIMATION_DURATION
    };
    var animations = createAnimationsToTest(t, timing);
    var doneCounter = 0;
    animations.forEach(function(animation) {
        var node = animation;
        if (animation.parent !== null) {
            node = node.parent;
        }
        var player = document.timeline.play(node);

        assert_equals(node.computedTiming.iterations, 0.5,
            'Wrong AnimationNode.computedTiming.iterations value');

        player.ready.then(t.step_func(function() {
            player.currentTime = ANIMATION_DURATION / 2 - 1;
            assert_approx_equals(window.getComputedStyle(animation.target), ANIMATION_TOP_0_5,
                COMPUTED_STYLE_EPSILON, 'Animation ' + type(node) + ' should be close to 0.5');
            player.currentTime = ANIMATION_DURATION / 2;
            assert_equals(window.getComputedStyle(animation.target), ANIMATION_TOP_DEFAULT,
                'Animation ' + type(node) + ' should be finished');
            doneCounter++;
            if (doneCounter === animations.length) {
                t.done();
            }
        }), t.unreached_func('Current ready promise should not be rejected'));
    });
}, 'Test that if value of AnimationTiming.iterations attribute is less than one ' +
    'then iteration is shortened');

async_test(function(t) {
    var timing = {
        iterations: 1.5,
        duration: ANIMATION_DURATION
    };
    var animations = createAnimationsToTest(t, timing);
    var doneCounter = 0;
    animations.forEach(function(animation) {
        var node = animation;
        if (animation.parent !== null) {
            node = node.parent;
        }
        var player = document.timeline.play(node);

        assert_equals(node.computedTiming.iterations, 1.5,
            'Wrong AnimationNode.computedTiming.iterations value');

        player.ready.then(t.step_func(function() {
            player.currentTime = ANIMATION_DURATION - 1;
            assert_approx_equals(window.getComputedStyle(animation.target), ANIMATION_TOP_1,
                COMPUTED_STYLE_EPSILON, 'Animation ' + type(node) + ' should be close to 1');
            player.currentTime = ANIMATION_DURATION;
            assert_equals(window.getComputedStyle(animation.target), ANIMATION_TOP_0,
                'Animation ' + type(node) + ' should be at 0');
            player.currentTime = 1.5 * ANIMATION_DURATION - 1;
            assert_approx_equals(window.getComputedStyle(animation.target), ANIMATION_TOP_0_5,
                COMPUTED_STYLE_EPSILON, 'Animation ' + type(node) + ' should be close to 0.5');
            player.currentTime = 1.5 * ANIMATION_DURATION;
            assert_equals(window.getComputedStyle(animation.target), ANIMATION_TOP_DEFAULT,
                'Animation ' + type(node) + ' should be finished');
            doneCounter++;
            if (doneCounter === animations.length) {
                t.done();
            }
        }), t.unreached_func('Current ready promise should not be rejected'));
    });
}, 'Test that if value of AnimationTiming.iterations attribute is more than one ' +
    'then animation is repeated accordingly');

async_test(function(t) {
    var timing = {
        iterations: Infinity,
        duration: ANIMATION_DURATION
    };
    var animations = createAnimationsToTest(t, timing);
    var doneCounter = 0;
    animations.forEach(function(animation) {
        var node = animation;
        if (animation.parent !== null) {
            node = node.parent;
        }
        var player = document.timeline.play(node);

        assert_equals(node.computedTiming.iterations, Infinity,
            'Wrong AnimationNode.computedTiming.iterations value');

        player.ready.then(t.step_func(function() {
            player.currentTime = Number.MAX_VALUE;
            assert_not_equals(window.getComputedStyle(animation.target), ANIMATION_TOP_DEFAULT,
                'Animation ' + type(node) + ' should be played');
            doneCounter++;
            if (doneCounter === animations.length) {
                t.done();
            }
        }), t.unreached_func('Current ready promise should not be rejected'));
    });
}, 'Test that if value of AnimationTiming.iterations attribute is positive infinity ' +
    'then animation is repeated endlessly');
</script>
</body>
