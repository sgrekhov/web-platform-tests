<!DOCTYPE html>
<meta charset=utf-8>
<title>AnimationTiming duration attribute test</title>
<meta name="assert" content="The iteration duration which is a real number greater than or equal to zero (including positive infinity) representing the time taken to complete a single iteration of the animation node.">
<link rel="help" href="http://w3c.github.io/web-animations/#dom-animationtiming-duration">
<link rel="author" title="Sergey G. Grekhov" href="mailto:sgrekhov@unipro.ru">
<script src="/resources/testharness.js"></script>
<script src="/resources/testharnessreport.js"></script>
<script src="../testcommon.js"></script>
<link rel="stylesheet" href="/resources/testharness.css">
<body>
<div id="log"></div>
<script>
function createAnimationsToTest(test, timing) {
    var animation1 = new Animation(createDiv(test), KEYFRAMES, timing);
    var animation2 = new Animation(createDiv(test), KEYFRAMES,
        {iterations: Infinity, duration: ANIMATION_DURATION});
    var animation3 = new Animation(createDiv(test), KEYFRAMES,
        {iterations: Infinity, duration: ANIMATION_DURATION});
    var animationGroup = new AnimationGroup([animation2], timing);
    var animationSequence = new AnimationSequence([animation3], timing);
    return [animation1, animation2, animation3];
}

async_test(function(t) {
    var timing = {
        duration: ANIMATION_DURATION
    };
    var animations = createAnimationsToTest(t, timing);
    var doneCounter = 0;
    animations.forEach(function(animation) {
        var node = animation;
        if (animation.parent !== null) {
            node = node.parent;
        }
        var player = document.timeline.play(node);

        assert_equals(node.computedTiming.duration, ANIMATION_DURATION,
            'Wrong AnimationNode.computedTiming.duration value for node ' + type(node));

        player.ready.then(t.step_func(function() {
            player.currentTime = ANIMATION_DURATION - 1;
            assert_approx_equals(window.getComputedStyle(animation.target), ANIMATION_TOP_1,
                COMPUTED_STYLE_EPSILON, 'Animation ' + type(node) + ' should be close to 1');
            player.currentTime = ANIMATION_DURATION;
            assert_equals(window.getComputedStyle(animation.target), ANIMATION_TOP_DEFAULT,
                'Animation ' + type(node) + ' should be finished');
            doneCounter++;
            if (doneCounter === animations.length) {
                t.done();
            }
        }), t.unreached_func('Current ready promise should not be rejected'));
    });
}, 'Test that if value of AnimationTiming.duration attribute returns iteration duration ' +
    'of the animation node');

async_test(function(t) {
    var timing = {
        duration: Infinity
    };
    var animations = createAnimationsToTest(t, timing);
    var doneCounter = 0;
    animations.forEach(function(animation) {
        var node = animation;
        if (animation.parent !== null) {
            node = node.parent;
        }
        var player = document.timeline.play(node);

        assert_equals(node.computedTiming.duration, Infinity,
            'Wrong AnimationNode.computedTiming.duration value for node ' + type(node));

        player.ready.then(t.step_func(function() {
            player.currentTime = Number.MAX_VALUE;
            assert_not_equals(window.getComputedStyle(animation.target), ANIMATION_TOP_DEFAULT,
                'Animation ' + type(node) + ' should not be finished');
            doneCounter++;
            if (doneCounter === animations.length) {
                t.done();
            }
        }), t.unreached_func('Current ready promise should not be rejected'));
    });
}, 'Test that if value of AnimationTiming.duration attribute is Infinity animation ' +
    'never be ended');

async_test(function(t) {
    var valuesToTest = [-1, -1000, -0.5, -Number.MAX_VALUE, Number.NaN, -Infinity, 'one'];
    var doneCounter = 0;
    valuesToTest.forEach(function(durationValue) {
        var timing = {
            duration: durationValue
        };
        var animation = new Animation(createDiv(test), KEYFRAMES, timing);
        var player = document.timeline.play(animation);

        assert_equals(node.computedTiming.duration, 0,
            'Animation.computedTiming.duration value should be zero');

         player.ready.then(t.step_func(function() {
             player.currentTime = 0;
             assert_equals(window.getComputedStyle(animation.target), ANIMATION_TOP_DEFAULT,
                 'Animation should not be performed');
             player.currentTime = 1;
             assert_equals(window.getComputedStyle(animation.target), ANIMATION_TOP_DEFAULT,
                 'Animation should not be performed');
             doneCounter++;
             if (doneCounter === valuesToTest.length) {
                 t.done();
             }
         }), t.unreached_func('Current ready promise should not be rejected'));
    });
}, 'Test that unsupported values of AnimationTiming.duration of Animation ' +
    'are treated as 0');

async_test(function(t) {
    var valuesToTest = [-1, -1000, -0.5, -Number.MAX_VALUE, Number.NaN, -Infinity, 'one'];
    var doneCounter = 0;
    valuesToTest.forEach(function(durationValue) {
        var timing = {
            duration: durationValue
        };
        var animation = new Animation(createDiv(test), KEYFRAMES, ANIMATION_DURATION);
        var animationGroup = new AnimationGroup([animation], timing);
        var player = document.timeline.play(animationGroup);

        assert_equals(animationGroup.computedTiming.duration, ANIMATION_DURATION,
            'AnimationGroup.computedTiming.duration value should be intrinsic iteration duration');

         player.ready.then(t.step_func(function() {
             player.currentTime = ANIMATION_DURATION - 1;
             assert_approx_equals(window.getComputedStyle(animation.target), ANIMATION_TOP_1,
                 COMPUTED_STYLE_EPSILON, 'Animation should be close to 1');
             player.currentTime = ANIMATION_DURATION;
             assert_equals(window.getComputedStyle(animation.target), ANIMATION_TOP_DEFAULT,
                 'Animation should be finished');
             doneCounter++;
             if (doneCounter === valuesToTest.length) {
                 t.done();
             }
         }), t.unreached_func('Current ready promise should not be rejected'));
    });
}, 'Test that unsupported values of AnimationTiming.duration of AnimationGroup ' +
    'are treated as auto and intrinsic iteration duration is used for timing calculations');

async_test(function(t) {
    var valuesToTest = [-1, -1000, -0.5, -Number.MAX_VALUE, Number.NaN, -Infinity, 'one'];
    var doneCounter = 0;
    valuesToTest.forEach(function(durationValue) {
        var timing = {
            duration: durationValue
        };
        var animation1 = new Animation(createDiv(test), KEYFRAMES, ANIMATION_DURATION);
        var animation2 = new Animation(createDiv(test), KEYFRAMES, ANIMATION_DURATION);
        var animationSequence = new AnimationSequence([animation1, animation2], timing);
        var player = document.timeline.play(animationSequence);

        assert_equals(animationSequence.computedTiming.duration, ANIMATION_DURATION,
            'AnimationSequence.computedTiming.duration value should be intrinsic iteration duration');

         player.ready.then(t.step_func(function() {
             player.currentTime = 2 * ANIMATION_DURATION - 1;
             assert_equals(window.getComputedStyle(animation1.target), ANIMATION_TOP_DEFAULT,
                 'Animation1 should be finished');
             assert_approx_equals(window.getComputedStyle(animation2.target), ANIMATION_TOP_1,
                 COMPUTED_STYLE_EPSILON, 'Animation2 should be close to 1');
             player.currentTime = 2 * ANIMATION_DURATION;
             assert_equals(window.getComputedStyle(animation1.target), ANIMATION_TOP_DEFAULT,
                 'Animation1 should be finished');
             assert_equals(window.getComputedStyle(animation2.target), ANIMATION_TOP_DEFAULT,
                 'Animation2 should be finished');
             doneCounter++;
             if (doneCounter === valuesToTest.length) {
                 t.done();
             }
         }), t.unreached_func('Current ready promise should not be rejected'));
    });
}, 'Test that unsupported values of AnimationTiming.duration of AnimationSequence ' +
    'are treated as auto and intrinsic iteration duration is used for timing calculations');

async_test(function(t) {
    var timing = {
        duration: 'auto'
    };
    var animation = new Animation(createDiv(test), KEYFRAMES, timing);
    var player = document.timeline.play(animation);

    assert_equals(animation.computedTiming.duration, 0,
        'Animation.computedTiming.duration value should be zero');

     player.ready.then(t.step_func(function() {
         player.currentTime = 0;
         assert_equals(window.getComputedStyle(animation.target), ANIMATION_TOP_DEFAULT,
             'Animation should not be performed');
         player.currentTime = 1;
         assert_equals(window.getComputedStyle(animation.target), ANIMATION_TOP_DEFAULT,
             'Animation should not be performed');
     }), t.unreached_func('Current ready promise should not be rejected'));
}, 'Test that if AnimationTiming.duration value is \'auto\' then Animation ' +
    'duration is 0');

async_test(function(t) {
    var timing = {
        duration: 'auto'
    };
    var animation1 = new Animation(createDiv(test), KEYFRAMES, ANIMATION_DURATION);
    var animation2 = new Animation(createDiv(test), KEYFRAMES, 2 * ANIMATION_DURATION);
    var animationGroup = new AnimationGroup([animation1, animation2]);
    var player = document.timeline.play(animationGroup);

    assert_equals(animationGroup.computedTiming.duration, 2 * ANIMATION_DURATION,
        'Animation.computedTiming.duration value should be zero');

     player.ready.then(t.step_func(function() {
         player.currentTime = 2 * ANIMATION_DURATION - 1;
         assert_equals(window.getComputedStyle(animation1.target), ANIMATION_TOP_DEFAULT,
             'Animation1 should be finished');
         assert_approx_equals(window.getComputedStyle(animation2.target), ANIMATION_TOP_1,
             COMPUTED_STYLE_EPSILON, 'Animation2 should not be finished');
         player.currentTime = 2 * ANIMATION_DURATION;
         assert_equals(window.getComputedStyle(animation1.target), ANIMATION_TOP_DEFAULT,
             'Animation1 should be finished');
         assert_equals(window.getComputedStyle(animation2.target), ANIMATION_TOP_DEFAULT,
             'Animation2 should be finished');
     }), t.unreached_func('Current ready promise should not be rejected'));
}, 'Test that if AnimationTiming.duration value is \'auto\' then AnimationGroup ' +
    'duration is max of its child animations durations');

async_test(function(t) {
    var timing = {
        duration: 'auto'
    };
    var animation1 = new Animation(createDiv(test), KEYFRAMES, ANIMATION_DURATION);
    var animation2 = new Animation(createDiv(test), KEYFRAMES, 2 * ANIMATION_DURATION);
    var animationSequence = new AnimationSequence([animation1, animation2]);
    var player = document.timeline.play(animationSequence);

    assert_equals(animationSequence.computedTiming.duration, 3 * ANIMATION_DURATION,
        'Animation.computedTiming.duration value should be zero');

     player.ready.then(t.step_func(function() {
         player.currentTime = 3 * ANIMATION_DURATION - 1;
         assert_equals(window.getComputedStyle(animation1.target), ANIMATION_TOP_DEFAULT,
             'Animation1 should be finished');
         assert_approx_equals(window.getComputedStyle(animation2.target), ANIMATION_TOP_1,
             COMPUTED_STYLE_EPSILON, 'Animation2 should not be finished');
         player.currentTime = 3 * ANIMATION_DURATION;
         assert_equals(window.getComputedStyle(animation1.target), ANIMATION_TOP_DEFAULT,
             'Animation1 should be finished');
         assert_equals(window.getComputedStyle(animation2.target), ANIMATION_TOP_DEFAULT,
             'Animation2 should be finished');
     }), t.unreached_func('Current ready promise should not be rejected'));
}, 'Test that if AnimationTiming.duration value is \'auto\' then AnimationSequence ' +
    'duration is sum of its child animations durations');
</script>
</body>
