<!DOCTYPE html>
<meta charset=utf-8>
<title>AnimationTiming direction attribute test</title>
<meta name="assert" content="The playback direction of the animation node as specified by one of the PlaybackDirection enumeration values">
<link rel="help" href="http://w3c.github.io/web-animations/#dom-animationtiming-direction">
<link rel="author" title="Sergey G. Grekhov" href="mailto:sgrekhov@unipro.ru">
<script src="/resources/testharness.js"></script>
<script src="/resources/testharnessreport.js"></script>
<script src="../testcommon.js"></script>
<link rel="stylesheet" href="/resources/testharness.css">
<body>
<div id="log"></div>
<script>
function createAnimationsToTest(test, timing) {
    var animation1 = new Animation(createDiv(test), KEYFRAMES, timing);
    var animation2 = new Animation(createDiv(test), KEYFRAMES, ANIMATION_DURATION);
    var animation3 = new Animation(createDiv(test), KEYFRAMES, ANIMATION_DURATION);
    var animationGroup = new AnimationGroup([animation2], timing);
    var animationSequence = new AnimationSequence([animation3], timing);
    return [animation1, animation2, animation3];
}

async_test(function(t) {
    var timing = {
        duration: ANIMATION_DURATION
    };
    var animations = createAnimationsToTest(t, timing);
    var doneCounter = 0;
    animations.forEach(function(animation) {
        var node = animation;
        if (animation.parent !== null) {
            node = node.parent;
        }
        var player = document.timeline.play(node);

        assert_equals(node.computedTiming.direction, 'normal',
            'Wrong AnimationNode.computedTiming.direction value');

        player.ready.then(t.step_func(function() {
            player.currentTime = 1;
            assert_approx_equals(window.getComputedStyle(animation.target).top, getExpectedTop(1),
                COMPUTED_STYLE_EPSILON, 'Animation ' + type(node) + ' should be performed in ' +
                'normal direction');
            player.currentTime = ANIMATION_DURATION / 4;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(ANIMATION_DURATION / 4), COMPUTED_STYLE_EPSILON,
                'Animation ' + type(node) + ' should be performed in normal direction');
            player.currentTime = ANIMATION_DURATION - 1;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(ANIMATION_DURATION - 1), COMPUTED_STYLE_EPSILON,
                'Animation ' + type(node) + ' should be performed in normal direction');
            doneCounter++;
            if (doneCounter === animations.length) {
                t.done();
            }
        }), t.unreached_func('Current ready promise should not be rejected'));
    });
}, 'Test that default value of AnimationTiming.direction is \'normal\' ' +
    'and animation is performed in normal direction');

async_test(function(t) {
    var timing = {
        direction: 'normal',
        duration: ANIMATION_DURATION,
        iterations: 3
    };
    var animations = createAnimationsToTest(t, timing);
    var doneCounter = 0;
    animations.forEach(function(animation) {
        var node = animation;
        if (animation.parent !== null) {
            node = node.parent;
        }
        var player = document.timeline.play(node);

        assert_equals(node.computedTiming.direction, 'normal',
            'Wrong AnimationNode.computedTiming.direction value');

        player.ready.then(t.step_func(function() {
            player.currentTime = 1;
            assert_approx_equals(window.getComputedStyle(animation.target).top, getExpectedTop(1),
                COMPUTED_STYLE_EPSILON, 'Animation ' + type(node) + ' should be performed in ' +
                'normal direction');
            player.currentTime = ANIMATION_DURATION / 4;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(ANIMATION_DURATION / 4), COMPUTED_STYLE_EPSILON,
                'Animation ' + type(node) + ' should be performed in normal direction');
            player.currentTime = ANIMATION_DURATION - 1;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(ANIMATION_DURATION - 1), COMPUTED_STYLE_EPSILON,
                'Animation ' + type(node) + ' should be performed in normal direction');

            player.currentTime = ANIMATION_DURATION;
            assert_equals(window.getComputedStyle(animation.target).top, ANIMATION_TOP_0,
                'Animation ' + type(node) + ' should be performed in normal direction for ' +
                'even iterations');
            player.currentTime = ANIMATION_DURATION + 1;
            assert_approx_equals(window.getComputedStyle(animation.target).top, getExpectedTop(1),
                COMPUTED_STYLE_EPSILON, 'Animation ' + type(node) + ' should be performed in ' +
                'normal direction for even iterations');
            player.currentTime = ANIMATION_DURATION + ANIMATION_DURATION / 4;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(ANIMATION_DURATION / 4), COMPUTED_STYLE_EPSILON,
                'Animation ' + type(node) + ' should be performed in normal direction for ' +
                'even iterations');
            player.currentTime =  2 * ANIMATION_DURATION - 1;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(ANIMATION_DURATION - 1), COMPUTED_STYLE_EPSILON,
                'Animation ' + type(node) + ' should be performed in normal direction for ' +
                'even iterations');

            player.currentTime = 2 * ANIMATION_DURATION;
            assert_equals(window.getComputedStyle(animation.target).top, ANIMATION_TOP_0,
                'Animation ' + type(node) + ' should be performed in normal direction for ' +
                'odd iterations');
            player.currentTime = 2 * ANIMATION_DURATION + 1;
            assert_approx_equals(window.getComputedStyle(animation.target).top, getExpectedTop(1),
                COMPUTED_STYLE_EPSILON, 'Animation ' + type(node) + ' should be performed in ' +
                'normal direction for odd iterations');
            player.currentTime = 2 * ANIMATION_DURATION + ANIMATION_DURATION / 4;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(ANIMATION_DURATION / 4), COMPUTED_STYLE_EPSILON,
                'Animation ' + type(node) + ' should be performed in normal direction for ' +
                'odd iterations');
            player.currentTime = 2 * ANIMATION_DURATION - 1;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(ANIMATION_DURATION - 1), COMPUTED_STYLE_EPSILON,
                'Animation ' + type(node) + ' should be performed in normal direction for ' +
                'odd iterations');

            doneCounter++;
            if (doneCounter === animations.length) {
                t.done();
            }
        }), t.unreached_func('Current ready promise should not be rejected'));
    });
}, 'Test that if AnimationTiming.direction value is \'normal\' then ' +
    'animation is performed in normal direction for all iterations');

async_test(function(t) {
    var timing = {
        direction: 'reverse',
        duration: ANIMATION_DURATION,
        iterations: 3
    };
    var animations = createAnimationsToTest(t, timing);
    var doneCounter = 0;
    animations.forEach(function(animation) {
        var node = animation;
        if (animation.parent !== null) {
            node = node.parent;
        }
        var player = document.timeline.play(node);

        assert_equals(node.computedTiming.direction, 'reverse',
            'Wrong AnimationNode.computedTiming.direction value');

        player.ready.then(t.step_func(function() {
            player.currentTime = 1;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(ANIMATION_DURATION - 1), COMPUTED_STYLE_EPSILON,
                'Animation ' + type(node) + ' should be performed in reversed direction');
            player.currentTime = ANIMATION_DURATION / 4;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(ANIMATION_DURATION * 3 / 4), COMPUTED_STYLE_EPSILON,
                'Animation ' + type(node) + ' should be performed in reversed direction');
            player.currentTime = ANIMATION_DURATION - 1;
            assert_approx_equals(window.getComputedStyle(animation.target).top, getExpectedTop(1),
                COMPUTED_STYLE_EPSILON, 'Animation ' + type(node) + ' should be performed in ' +
                'reversed direction');

            player.currentTime = ANIMATION_DURATION;
            assert_equals(window.getComputedStyle(animation.target).top, ANIMATION_TOP_1,
                'Animation ' + type(node) + ' should be performed in reversed direction for ' +
                'even iterations');
            player.currentTime = ANIMATION_DURATION + 1;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(ANIMATION_DURATION - 1), COMPUTED_STYLE_EPSILON,
                'Animation ' + type(node) + ' should be performed in ' +
                'reversed direction for even iterations');
            player.currentTime = ANIMATION_DURATION + ANIMATION_DURATION / 4;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(ANIMATION_DURATION * 3 / 4), COMPUTED_STYLE_EPSILON,
                'Animation ' + type(node) + ' should be performed in reversed direction for ' +
                'even iterations');
            player.currentTime =  2 * ANIMATION_DURATION - 1;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(1), COMPUTED_STYLE_EPSILON,
                'Animation ' + type(node) + ' should be performed in reversed direction for ' +
                'even iterations');

            player.currentTime = 2 * ANIMATION_DURATION;
            assert_equals(window.getComputedStyle(animation.target).top, ANIMATION_TOP_1,
                'Animation ' + type(node) + ' should be performed in reversed direction for ' +
                'odd iterations');
            player.currentTime = 2 * ANIMATION_DURATION + 1;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(ANIMATION_DURATION - 1), COMPUTED_STYLE_EPSILON,
                'Animation ' + type(node) + ' should be performed in ' +
                'reversed direction for odd iterations');
            player.currentTime = 2 * ANIMATION_DURATION + ANIMATION_DURATION / 4;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(ANIMATION_DURATION * 3 / 4), COMPUTED_STYLE_EPSILON,
                'Animation ' + type(node) + ' should be performed in reversed direction for ' +
                'odd iterations');
            player.currentTime = 2 * ANIMATION_DURATION - 1;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(1), COMPUTED_STYLE_EPSILON,
                'Animation ' + type(node) + ' should be performed in reversed direction for ' +
                'odd iterations');

            doneCounter++;
            if (doneCounter === animations.length) {
                t.done();
            }
        }), t.unreached_func('Current ready promise should not be rejected'));
    });
}, 'Test that if AnimationTiming.direction value is \'reverse\' then ' +
    'animation is performed in reversed direction for all iterations');

async_test(function(t) {
    var timing = {
        direction: 'alternate',
        duration: ANIMATION_DURATION,
        iterations: 3
    };
    var animations = createAnimationsToTest(t, timing);
    var doneCounter = 0;
    animations.forEach(function(animation) {
        var node = animation;
        if (animation.parent !== null) {
            node = node.parent;
        }
        var player = document.timeline.play(node);

        assert_equals(node.computedTiming.direction, 'alternate',
            'Wrong AnimationNode.computedTiming.direction value');

        player.ready.then(t.step_func(function() {
            player.currentTime = 1;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(ANIMATION_DURATION - 1), COMPUTED_STYLE_EPSILON,
                'Animation ' + type(node) + ' should be performed in reversed direction');
            player.currentTime = ANIMATION_DURATION / 4;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(ANIMATION_DURATION * 3 / 4), COMPUTED_STYLE_EPSILON,
                'Animation ' + type(node) + ' should be performed in reversed direction');
            player.currentTime = ANIMATION_DURATION - 1;
            assert_approx_equals(window.getComputedStyle(animation.target).top, getExpectedTop(1),
                COMPUTED_STYLE_EPSILON, 'Animation ' + type(node) + ' should be performed in ' +
                'reversed direction');

            player.currentTime = ANIMATION_DURATION;
            assert_equals(window.getComputedStyle(animation.target).top, ANIMATION_TOP_0,
                'Animation ' + type(node) + ' should be performed in normal direction for ' +
                'even iterations');
            player.currentTime = ANIMATION_DURATION + 1;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(1), COMPUTED_STYLE_EPSILON,
                'Animation ' + type(node) + ' should be performed in ' +
                'normal direction for even iterations');
            player.currentTime = ANIMATION_DURATION + ANIMATION_DURATION / 4;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(ANIMATION_DURATION / 4), COMPUTED_STYLE_EPSILON,
                'Animation ' + type(node) + ' should be performed in normal direction for ' +
                'even iterations');
            player.currentTime =  2 * ANIMATION_DURATION - 1;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(ANIMATION_DURATION - 1), COMPUTED_STYLE_EPSILON,
                'Animation ' + type(node) + ' should be performed in normal direction for ' +
                'even iterations');

            player.currentTime = 2 * ANIMATION_DURATION;
            assert_equals(window.getComputedStyle(animation.target).top, ANIMATION_TOP_1,
                'Animation ' + type(node) + ' should be performed in reversed direction for ' +
                'odd iterations');
            player.currentTime = 2 * ANIMATION_DURATION + 1;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(ANIMATION_DURATION - 1), COMPUTED_STYLE_EPSILON,
                'Animation ' + type(node) + ' should be performed in ' +
                'reversed direction for odd iterations');
            player.currentTime = 2 * ANIMATION_DURATION + ANIMATION_DURATION / 4;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(ANIMATION_DURATION * 3 / 4), COMPUTED_STYLE_EPSILON,
                'Animation ' + type(node) + ' should be performed in reversed direction for ' +
                'odd iterations');
            player.currentTime = 2 * ANIMATION_DURATION - 1;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(1), COMPUTED_STYLE_EPSILON,
                'Animation ' + type(node) + ' should be performed in reversed direction for ' +
                'odd iterations');
            doneCounter++;
            if (doneCounter === animations.length) {
                t.done();
            }
        }), t.unreached_func('Current ready promise should not be rejected'));
    });
}, 'Test that if AnimationTiming.direction value is \'alternate\' then ' +
    'animation is performed in reversed direction for odd iterations and ' +
    'in normal directions for even iterations');

async_test(function(t) {
    var timing = {
        direction: 'alternate-reverse',
        duration: ANIMATION_DURATION,
        iterations: 3
    };
    var animations = createAnimationsToTest(t, timing);
    var doneCounter = 0;
    animations.forEach(function(animation) {
        var node = animation;
        if (animation.parent !== null) {
            node = node.parent;
        }
        var player = document.timeline.play(node);

        assert_equals(node.computedTiming.direction, 'alternate-reverse',
            'Wrong AnimationNode.computedTiming.direction value');

        player.ready.then(t.step_func(function() {
            player.currentTime = 1;
            assert_approx_equals(window.getComputedStyle(animation.target).top, getExpectedTop(1),
                COMPUTED_STYLE_EPSILON, 'Animation ' + type(node) + ' should be performed in ' +
                'normal direction');
            player.currentTime = ANIMATION_DURATION / 4;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(ANIMATION_DURATION / 4), COMPUTED_STYLE_EPSILON,
                'Animation ' + type(node) + ' should be performed in normal direction');
            player.currentTime = ANIMATION_DURATION - 1;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(ANIMATION_DURATION - 1), COMPUTED_STYLE_EPSILON,
                'Animation ' + type(node) + ' should be performed in normal direction');

            player.currentTime = ANIMATION_DURATION;
            assert_equals(window.getComputedStyle(animation.target).top, ANIMATION_TOP_1,
                'Animation ' + type(node) + ' should be performed in reversed direction for ' +
                'even iterations');
            player.currentTime = ANIMATION_DURATION + 1;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(ANIMATION_DURATION - 1), COMPUTED_STYLE_EPSILON,
                'Animation ' + type(node) + ' should be performed in ' +
                'reversed direction for even iterations');
            player.currentTime = ANIMATION_DURATION + ANIMATION_DURATION / 4;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(ANIMATION_DURATION * 3 / 4), COMPUTED_STYLE_EPSILON,
                'Animation ' + type(node) + ' should be performed in reversed direction for ' +
                'even iterations');
            player.currentTime =  2 * ANIMATION_DURATION - 1;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(1), COMPUTED_STYLE_EPSILON,
                'Animation ' + type(node) + ' should be performed in reversed direction for ' +
                'even iterations');

            player.currentTime = 2 * ANIMATION_DURATION;
            assert_equals(window.getComputedStyle(animation.target).top, ANIMATION_TOP_0,
                'Animation ' + type(node) + ' should be performed in normal direction for ' +
                'odd iterations');
            player.currentTime = 2 * ANIMATION_DURATION + 1;
            assert_approx_equals(window.getComputedStyle(animation.target).top, getExpectedTop(1),
                COMPUTED_STYLE_EPSILON, 'Animation ' + type(node) + ' should be performed in ' +
                'normal direction for odd iterations');
            player.currentTime = 2 * ANIMATION_DURATION + ANIMATION_DURATION / 4;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(ANIMATION_DURATION / 4), COMPUTED_STYLE_EPSILON,
                'Animation ' + type(node) + ' should be performed in normal direction for ' +
                'odd iterations');
            player.currentTime = 2 * ANIMATION_DURATION - 1;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(ANIMATION_DURATION - 1), COMPUTED_STYLE_EPSILON,
                'Animation ' + type(node) + ' should be performed in normal direction for ' +
                'odd iterations');
            doneCounter++;
            if (doneCounter === animations.length) {
                t.done();
            }
        }), t.unreached_func('Current ready promise should not be rejected'));
    });
}, 'Test that if AnimationTiming.direction value is \'alternate-reverse\' then ' +
    'animation is performed in normal direction for odd iterations and ' +
    'in reverse direction for even iterations');

async_test(function(t) {
    var timing = {
        direction: 'normal',
        duration: ANIMATION_DURATION
    };
    var animation = new Animation(createDiv(t), KEYFRAMES, timing);
    var animationGroup = new AnimationGroup([animation], timing);
    var animationSequence = new AnimationSequence([animation], timing);
    var groups = [animationGroup, animationSequence];
    var doneCounter = 0;
    groups.forEach(function(group) {
        var player = document.timeline.play(group);
        assert_equals(animation.computedTiming.direction, 'normal',
            'Wrong Animation.computedTiming.direction value');
        assert_equals(group.computedTiming.direction, 'normal',
            'Wrong ' + type(group) + '.computedTiming.direction value');

        player.ready.then(t.step_func(function() {
            player.currentTime = 1;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(1), COMPUTED_STYLE_EPSILON,
                'Animation should be performed in normal direction');
            player.currentTime = ANIMATION_DURATION / 4;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(ANIMATION_DURATION / 4), COMPUTED_STYLE_EPSILON,
                'Animation should be performed in normal direction');
            player.currentTime = ANIMATION_DURATION - 1;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(ANIMATION_DURATION - 1), COMPUTED_STYLE_EPSILON,
                'Animation should be performed in normal direction');
            doneCounter++;
            if (doneCounter === groups.length) {
                t.done();
            }
        }), t.unreached_func('Current ready promise should not be rejected'));
    });
}, 'Test that animation is performed in normal direction if both animation and ' +
    'it\'s parent group have \'normal\' direction');

async_test(function(t) {
    var timing = {
        direction: 'reverse',
        duration: ANIMATION_DURATION
    };
    var animation = new Animation(createDiv(t), KEYFRAMES, timing);
    var animationGroup = new AnimationGroup([animation], timing);
    var animationSequence = new AnimationSequence([animation], timing);
    var groups = [animationGroup, animationSequence];
    var doneCounter = 0;
    groups.forEach(function(group) {
        var player = document.timeline.play(group);

        assert_equals(animation.computedTiming.direction, 'reverse',
            'Wrong Animation.computedTiming.direction value');
        assert_equals(group.computedTiming.direction, 'reverse',
            'Wrong ' + type(group) + '.computedTiming.direction value');

        player.ready.then(t.step_func(function() {
            player.currentTime = 1;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(1), COMPUTED_STYLE_EPSILON,
                'Animation should be performed in normal direction');
            player.currentTime = ANIMATION_DURATION / 4;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(ANIMATION_DURATION / 4), COMPUTED_STYLE_EPSILON,
                'Animation should be performed in normal direction');
            player.currentTime = ANIMATION_DURATION - 1;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(ANIMATION_DURATION - 1), COMPUTED_STYLE_EPSILON,
                'Animation should be performed in normal direction');
            doneCounter++;
            if (doneCounter === groups.length) {
                t.done();
            }
        }), t.unreached_func('Current ready promise should not be rejected'));
    });
}, 'Test that animation is performed in normal direction if both animation and ' +
    'it\'s parent group have \'reverse\' direction');

async_test(function(t) {
    var timing = {
        direction: 'alternate',
        duration: ANIMATION_DURATION,
        iterations: 2
    };
    var animation = new Animation(createDiv(t), KEYFRAMES, timing);
    var animationGroup = new AnimationGroup([animation], timing);
    var animationSequence = new AnimationSequence([animation], timing);
    var groups = [animationGroup, animationSequence];
    var doneCounter = 0;
    groups.forEach(function(group) {
        var player = document.timeline.play(group);

        assert_equals(animation.computedTiming.direction, 'alternate',
            'Wrong Animation.computedTiming.direction value');
        assert_equals(group.computedTiming.direction, 'alternate',
            'Wrong ' + type(group) + '.computedTiming.direction value');

        player.ready.then(t.step_func(function() {
            // First iteration of the group. Direction is reversed
            // Therefore second iteration of the animation goes first
            // Second iteration - direction is normal but reversed because of the group
            player.currentTime = 1;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(ANIMATION_DURATION - 1), COMPUTED_STYLE_EPSILON,
                'Animation should be performed in reversed direction');
            player.currentTime = ANIMATION_DURATION / 4;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(ANIMATION_DURATION * 3 / 4), COMPUTED_STYLE_EPSILON,
                'Animation should be performed in reversed direction');
            player.currentTime = ANIMATION_DURATION - 1;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(1), COMPUTED_STYLE_EPSILON,
                'Animation should be performed in reversed direction');

            // Now the first iteration. Direction is reversed but normal by the group
            player.currentTime = ANIMATION_DURATION + 1;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(1), COMPUTED_STYLE_EPSILON,
                'Animation should be performed in normal direction');
            player.currentTime = ANIMATION_DURATION + ANIMATION_DURATION / 4;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(ANIMATION_DURATION / 4), COMPUTED_STYLE_EPSILON,
                'Animation should be performed in normal direction');
            player.currentTime = 2 * ANIMATION_DURATION - 1;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(ANIMATION_DURATION - 1), COMPUTED_STYLE_EPSILON,
                'Animation should be performed in normal direction');

            // Second iteration of the group. Direction is normal
            // First iteration of the animation - direction is reversed
            player.currentTime = 2 * ANIMATION_DURATION + 1;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(ANIMATION_DURATION - 1), COMPUTED_STYLE_EPSILON,
                'Animation should be performed in reversed direction');
            player.currentTime = 2 * ANIMATION_DURATION + ANIMATION_DURATION / 4;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(ANIMATION_DURATION * 3 / 4), COMPUTED_STYLE_EPSILON,
                'Animation should be performed in reversed direction');
            player.currentTime = 3 * ANIMATION_DURATION - 1;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(1), COMPUTED_STYLE_EPSILON,
                'Animation should be performed in reversed direction');

            // The second iteration of the animation. Direction is normal
            player.currentTime = 3 * ANIMATION_DURATION + 1;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(1), COMPUTED_STYLE_EPSILON,
                'Animation should be performed in normal direction');
            player.currentTime = 3 * ANIMATION_DURATION + ANIMATION_DURATION / 4;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(ANIMATION_DURATION / 4), COMPUTED_STYLE_EPSILON,
                'Animation should be performed in normal direction');
            player.currentTime = 4 * ANIMATION_DURATION - 1;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(ANIMATION_DURATION - 1), COMPUTED_STYLE_EPSILON,
                'Animation should be performed in normal direction');
            doneCounter++;
            if (doneCounter === groups.length) {
                t.done();
            }
        }), t.unreached_func('Current ready promise should not be rejected'));
    });
}, 'Test that animation is performed in appropriate directions if both animation and ' +
    'it\'s parent group have \'alternate\' direction');

async_test(function(t) {
    var timing = {
        direction: 'alternate-reverse',
        duration: ANIMATION_DURATION,
        iterations: 2
    };
    var animation = new Animation(createDiv(t), KEYFRAMES, timing);
    var animationGroup = new AnimationGroup([animation], timing);
    var animationSequence = new AnimationSequence([animation], timing);
    var groups = [animationGroup, animationSequence];
    var doneCounter = 0;
    groups.forEach(function(group) {
        var player = document.timeline.play(group);

        assert_equals(animation.computedTiming.direction, 'alternate-reverse',
            'Wrong Animation.computedTiming.direction value');
        assert_equals(group.computedTiming.direction, 'alternate-reverse',
            'Wrong ' + type(group) + '.computedTiming.direction value');

        player.ready.then(t.step_func(function() {
            // First iteration of the group. Direction is normal
            // First iteration of the animation. Direction is normal
            player.currentTime = 1;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(1), COMPUTED_STYLE_EPSILON,
                'Animation should be performed in normal direction');
            player.currentTime = ANIMATION_DURATION / 4;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(ANIMATION_DURATION / 4), COMPUTED_STYLE_EPSILON,
                'Animation should be performed in normal direction');
            player.currentTime = ANIMATION_DURATION - 1;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(ANIMATION_DURATION - 1), COMPUTED_STYLE_EPSILON,
                'Animation should be performed in normal direction');

            // Second iteration of the animation. Direction is reversed
            player.currentTime = ANIMATION_DURATION + 1;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(ANIMATION_DURATION - 1), COMPUTED_STYLE_EPSILON,
                'Animation should be performed in reversed direction');
            player.currentTime = ANIMATION_DURATION + ANIMATION_DURATION / 4;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(ANIMATION_DURATION * 3 / 4), COMPUTED_STYLE_EPSILON,
                'Animation should be performed in reversed direction');
            player.currentTime = 2 * ANIMATION_DURATION - 1;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(1), COMPUTED_STYLE_EPSILON,
                'Animation should be performed in reversed direction');

            // Second iteration of the group. Direction is reversed.
            // So the second iteration of the animation goes first.
            // Direction is reversed but because of the group - normal
            player.currentTime = 2 * ANIMATION_DURATION + 1;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(1), COMPUTED_STYLE_EPSILON,
                'Animation should be performed in normal direction');
            player.currentTime = 2 * ANIMATION_DURATION + ANIMATION_DURATION / 4;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(ANIMATION_DURATION / 4), COMPUTED_STYLE_EPSILON,
                'Animation should be performed in normal direction');
            player.currentTime = 3 * ANIMATION_DURATION - 1;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(ANIMATION_DURATION - 1), COMPUTED_STYLE_EPSILON,
                'Animation should be performed in normal direction');

            // The first iteration of the animation.
            // Direction is normal but reversed because of the group
            player.currentTime = 3 * ANIMATION_DURATION + 1;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(ANIMATION_DURATION - 1), COMPUTED_STYLE_EPSILON,
                'Animation should be performed in reversed direction');
            player.currentTime = 3 * ANIMATION_DURATION + ANIMATION_DURATION / 4;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(ANIMATION_DURATION * 3 / 4), COMPUTED_STYLE_EPSILON,
                'Animation should be performed in reversed direction');
            player.currentTime = 4 * ANIMATION_DURATION - 1;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(1), COMPUTED_STYLE_EPSILON,
                'Animation should be performed in reversed direction');
            doneCounter++;
            if (doneCounter === groups.length) {
                t.done();
            }
        }), t.unreached_func('Current ready promise should not be rejected'));
    });
}, 'Test that animation is performed in appropriate directions if both animation and ' +
    'it\'s parent group have \'alternate-reverse\' direction');

async_test(function(t) {
    var animationTiming = {
        direction: 'alternate',
        duration: ANIMATION_DURATION,
        iterations: 2
    };
    var groupTiming = {
        direction: 'reverse',
        duration: ANIMATION_DURATION,
        iterations: 2
    };
    var animation = new Animation(createDiv(t), KEYFRAMES, animationTiming);
    var animationGroup = new AnimationGroup([animation], groupTiming);
    var animationSequence = new AnimationSequence([animation], groupTiming);
    var groups = [animationGroup, animationSequence];
    var doneCounter = 0;
    groups.forEach(function(group) {
        var player = document.timeline.play(group);

        assert_equals(animation.computedTiming.direction, 'alternate',
            'Wrong Animation.computedTiming.direction value');
        assert_equals(group.computedTiming.direction, 'reverse',
            'Wrong ' + type(group) + '.computedTiming.direction value');

        player.ready.then(t.step_func(function() {
            // First iteration of the group. Direction is reversed.
            // So the second iteration of the animation goes first
            // Second iteration of the animation. Direction is normal
            // but reversed because of the group
            player.currentTime = 1;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(ANIMATION_DURATION - 1), COMPUTED_STYLE_EPSILON,
                'Animation should be performed in reversed direction');
            player.currentTime = ANIMATION_DURATION / 4;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(ANIMATION_DURATION * 3 / 4), COMPUTED_STYLE_EPSILON,
                'Animation should be performed in reversed direction');
            player.currentTime = ANIMATION_DURATION - 1;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(1), COMPUTED_STYLE_EPSILON,
                'Animation should be performed in reversed direction');

            // First iteration of the animation. Direction is reversed
            // but normal because of the group
            player.currentTime = ANIMATION_DURATION + 1;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(1), COMPUTED_STYLE_EPSILON,
                'Animation should be performed in normal direction');
            player.currentTime = ANIMATION_DURATION + ANIMATION_DURATION / 4;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(ANIMATION_DURATION / 4), COMPUTED_STYLE_EPSILON,
                'Animation should be performed in normal direction');
            player.currentTime = 2 * ANIMATION_DURATION - 1;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(ANIMATION_DURATION - 1), COMPUTED_STYLE_EPSILON,
                'Animation should be performed in normal direction');

            // Second iteration of the group. Direction is reversed.
            // So the second iteration of the animation goes first.
            // Direction is normal but reversed because of the group
            player.currentTime = 2 * ANIMATION_DURATION + 1;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(ANIMATION_DURATION - 1), COMPUTED_STYLE_EPSILON,
                'Animation should be performed in reversed direction');
            player.currentTime = 2 * ANIMATION_DURATION + ANIMATION_DURATION / 4;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(ANIMATION_DURATION * 3 / 4), COMPUTED_STYLE_EPSILON,
                'Animation should be performed in reversed direction');
            player.currentTime = 3 * ANIMATION_DURATION - 1;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(1), COMPUTED_STYLE_EPSILON,
                'Animation should be performed in reversed direction');

            // The first iteration of the animation.
            // Direction is reversed but normal because of the group
            player.currentTime = 3 * ANIMATION_DURATION + 1;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(1), COMPUTED_STYLE_EPSILON,
                'Animation should be performed in normal direction');
            player.currentTime = 3 * ANIMATION_DURATION + ANIMATION_DURATION / 4;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(ANIMATION_DURATION / 4), COMPUTED_STYLE_EPSILON,
                'Animation should be performed in normal direction');
            player.currentTime = 4 * ANIMATION_DURATION - 1;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(ANIMATION_DURATION - 1), COMPUTED_STYLE_EPSILON,
                'Animation should be performed in normal direction');
            doneCounter++;
            if (doneCounter === groups.length) {
                t.done();
            }
        }), t.unreached_func('Current ready promise should not be rejected'));
    });
}, 'Test that animation is performed in appropriate directions when animation is played ' +
    'in \'alternate\' direction and it\'s parent group in \'reverse\' direction');

async_test(function(t) {
    var animationTiming = {
        direction: 'alternate-reverse',
        duration: ANIMATION_DURATION,
        iterations: 2
    };
    var groupTiming = {
        direction: 'reverse',
        duration: ANIMATION_DURATION,
        iterations: 2
    };
    var animation = new Animation(createDiv(t), KEYFRAMES, animationTiming);
    var animationGroup = new AnimationGroup([animation], groupTiming);
    var animationSequence = new AnimationSequence([animation], groupTiming);
    var groups = [animationGroup, animationSequence];
    var doneCounter = 0;
    groups.forEach(function(group) {
        var player = document.timeline.play(group);

        assert_equals(animation.computedTiming.direction, 'alternate-reverse',
            'Wrong Animation.computedTiming.direction value');
        assert_equals(group.computedTiming.direction, 'reverse',
            'Wrong ' + type(group) + '.computedTiming.direction value');

        player.ready.then(t.step_func(function() {
            // First iteration of the group. Direction is reversed.
            // So the second iteration of the animation goes first
            // For the second iteration of the animation direction is reversed
            // but normal because of the group
            player.currentTime = 1;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(1), COMPUTED_STYLE_EPSILON,
                'Animation should be performed in normal direction');
            player.currentTime = ANIMATION_DURATION / 4;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(ANIMATION_DURATION / 4), COMPUTED_STYLE_EPSILON,
                'Animation should be performed in normal direction');
            player.currentTime = ANIMATION_DURATION - 1;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(ANIMATION_DURATION - 1), COMPUTED_STYLE_EPSILON,
                'Animation should be performed in normal direction');

            // First iteration of the animation. Direction is normal
            // but reversed because of the group
            player.currentTime = ANIMATION_DURATION + 1;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(ANIMATION_DURATION - 1), COMPUTED_STYLE_EPSILON,
                'Animation should be performed in reversed direction');
            player.currentTime = ANIMATION_DURATION + ANIMATION_DURATION / 4;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(ANIMATION_DURATION * 3 / 4), COMPUTED_STYLE_EPSILON,
                'Animation should be performed in reversed direction');
            player.currentTime = 2 * ANIMATION_DURATION - 1;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(1), COMPUTED_STYLE_EPSILON,
                'Animation should be performed in reversed direction');

            // Second iteration of the group. Direction is reversed.
            // So the second iteration of the animation goes first.
            // Direction is reversed but normal because of the group
            player.currentTime = 2 * ANIMATION_DURATION + 1;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(1), COMPUTED_STYLE_EPSILON,
                'Animation should be performed in normal direction');
            player.currentTime = 2 * ANIMATION_DURATION + ANIMATION_DURATION / 4;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(ANIMATION_DURATION / 4), COMPUTED_STYLE_EPSILON,
                'Animation should be performed in normal direction');
            player.currentTime = 3 * ANIMATION_DURATION - 1;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(ANIMATION_DURATION - 1), COMPUTED_STYLE_EPSILON,
                'Animation should be performed in normal direction');

            // The first iteration of the animation.
            // Direction is normal but reversed because of the group
            player.currentTime = 3 * ANIMATION_DURATION + 1;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(ANIMATION_DURATION - 1), COMPUTED_STYLE_EPSILON,
                'Animation should be performed in reversed direction');
            player.currentTime = 3 * ANIMATION_DURATION + ANIMATION_DURATION / 4;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(ANIMATION_DURATION * 3 / 4), COMPUTED_STYLE_EPSILON,
                'Animation should be performed in reversed direction');
            player.currentTime = 4 * ANIMATION_DURATION - 1;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(1), COMPUTED_STYLE_EPSILON,
                'Animation should be performed in reversed direction');
            doneCounter++;
            if (doneCounter === groups.length) {
                t.done();
            }
        }), t.unreached_func('Current ready promise should not be rejected'));
    });
}, 'Test that animation is performed in appropriate directions when animation is played ' +
    'in \'alternate-reverse\' direction and it\'s parent group in \'reverse\' direction');

async_test(function(t) {
    var animationTiming = {
        direction: 'reverse',
        duration: ANIMATION_DURATION,
        iterations: 2
    };
    var groupTiming = {
        direction: 'alternate',
        duration: ANIMATION_DURATION,
        iterations: 2
    };
    var animation = new Animation(createDiv(t), KEYFRAMES, animationTiming);
    var animationGroup = new AnimationGroup([animation], groupTiming);
    var animationSequence = new AnimationSequence([animation], groupTiming);
    var groups = [animationGroup, animationSequence];
    var doneCounter = 0;
    groups.forEach(function(group) {
        var player = document.timeline.play(group);

        assert_equals(animation.computedTiming.direction, 'reverse',
            'Wrong Animation.computedTiming.direction value');
        assert_equals(group.computedTiming.direction, 'alternate',
            'Wrong ' + type(group) + '.computedTiming.direction value');

        player.ready.then(t.step_func(function() {
            // First iteration of the group. Direction is reversed.
            // So the second iteration of the animation goes first
            // For the second iteration of the animation direction is reversed
            // but normal because of the group
            player.currentTime = 1;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(1), COMPUTED_STYLE_EPSILON,
                'Animation should be performed in normal direction');
            player.currentTime = ANIMATION_DURATION / 4;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(ANIMATION_DURATION / 4), COMPUTED_STYLE_EPSILON,
                'Animation should be performed in normal direction');
            player.currentTime = ANIMATION_DURATION - 1;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(ANIMATION_DURATION - 1), COMPUTED_STYLE_EPSILON,
                   'Animation should be performed in normal direction');

            // First iteration of the animation. Direction is reversed
            // but normal because of the group
            player.currentTime = ANIMATION_DURATION + 1;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(1), COMPUTED_STYLE_EPSILON,
                'Animation should be performed in normal direction');
            player.currentTime = ANIMATION_DURATION + ANIMATION_DURATION / 4;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(ANIMATION_DURATION / 4), COMPUTED_STYLE_EPSILON,
                'Animation should be performed in normal direction');
            player.currentTime = 2 * ANIMATION_DURATION - 1;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(ANIMATION_DURATION - 1), COMPUTED_STYLE_EPSILON,
                'Animation should be performed in normal direction');

            // Second iteration of the group. Direction is normal.
            // The first iteration of the animation, direction is reversed
            player.currentTime = 2 * ANIMATION_DURATION + 1;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(ANIMATION_DURATION - 1), COMPUTED_STYLE_EPSILON,
                'Animation should be performed in reversed direction');
            player.currentTime = 2 * ANIMATION_DURATION + ANIMATION_DURATION / 4;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(ANIMATION_DURATION * 3 / 4), COMPUTED_STYLE_EPSILON,
                'Animation should be performed in reversed direction');
            player.currentTime = 3 * ANIMATION_DURATION - 1;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(1), COMPUTED_STYLE_EPSILON,
                'Animation should be performed in reversed direction');

            // The second iteration of the animation. Direction is reversed
            player.currentTime = 3 * ANIMATION_DURATION + 1;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(ANIMATION_DURATION - 1), COMPUTED_STYLE_EPSILON,
                'Animation should be performed in reversed direction');
            player.currentTime = 3 * ANIMATION_DURATION + ANIMATION_DURATION / 4;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(ANIMATION_DURATION * 3 / 4), COMPUTED_STYLE_EPSILON,
                'Animation should be performed in reversed direction');
            player.currentTime = 4 * ANIMATION_DURATION - 1;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(1), COMPUTED_STYLE_EPSILON,
                'Animation should be performed in reversed direction');
            doneCounter++;
            if (doneCounter === groups.length) {
                t.done();
            }
        }), t.unreached_func('Current ready promise should not be rejected'));
    });
}, 'Test that animation is performed in appropriate directions when animation is played ' +
    'in \'reverse\' direction and it\'s parent group in \'alternate\' direction');

async_test(function(t) {
    var animationTiming = {
        direction: 'alternate-reverse',
        duration: ANIMATION_DURATION,
        iterations: 2
    };
    var groupTiming = {
        direction: 'alternate',
        duration: ANIMATION_DURATION,
        iterations: 2
    };
    var animation = new Animation(createDiv(t), KEYFRAMES, animationTiming);
    var animationGroup = new AnimationGroup([animation], groupTiming);
    var animationSequence = new AnimationSequence([animation], groupTiming);
    var groups = [animationGroup, animationSequence];
    var doneCounter = 0;
    groups.forEach(function(group) {
        var player = document.timeline.play(group);

        assert_equals(animation.computedTiming.direction, 'alternate-reverse',
            'Wrong Animation.computedTiming.direction value');
        assert_equals(group.computedTiming.direction, 'alternate',
            'Wrong ' + type(group) + '.computedTiming.direction value');

        player.ready.then(t.step_func(function() {
            // First iteration of the group. Direction is reversed.
            // So the second iteration of the animation goes first
            // For the second iteration of the animation direction is reversed
            // but normal because of the group
            player.currentTime = 1;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(1), COMPUTED_STYLE_EPSILON,
                'Animation should be performed in normal direction');
            player.currentTime = ANIMATION_DURATION / 4;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(ANIMATION_DURATION / 4), COMPUTED_STYLE_EPSILON,
                'Animation should be performed in normal direction');
            player.currentTime = ANIMATION_DURATION - 1;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(ANIMATION_DURATION - 1), COMPUTED_STYLE_EPSILON,
                   'Animation should be performed in normal direction');

            // First iteration of the animation. Direction is normal
            // but reversed because of the group
            player.currentTime = ANIMATION_DURATION + 1;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(ANIMATION_DURATION - 1), COMPUTED_STYLE_EPSILON,
                'Animation should be performed in reversed direction');
            player.currentTime = ANIMATION_DURATION + ANIMATION_DURATION / 4;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(ANIMATION_DURATION * 3 / 4), COMPUTED_STYLE_EPSILON,
                'Animation should be performed in reversed direction');
            player.currentTime = 2 * ANIMATION_DURATION - 1;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(1), COMPUTED_STYLE_EPSILON,
                'Animation should be performed in reversed direction');

            // Second iteration of the group. Direction is normal.
            // The first iteration of the animation, direction is reversed
            player.currentTime = 2 * ANIMATION_DURATION + 1;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(ANIMATION_DURATION - 1), COMPUTED_STYLE_EPSILON,
                'Animation should be performed in reversed direction');
            player.currentTime = 2 * ANIMATION_DURATION + ANIMATION_DURATION / 4;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(ANIMATION_DURATION * 3 / 4), COMPUTED_STYLE_EPSILON,
                'Animation should be performed in reversed direction');
            player.currentTime = 3 * ANIMATION_DURATION - 1;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(1), COMPUTED_STYLE_EPSILON,
                'Animation should be performed in reversed direction');

            // The second iteration of the animation. Direction is normal
            player.currentTime = 3 * ANIMATION_DURATION + 1;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(1), COMPUTED_STYLE_EPSILON,
                'Animation should be performed in normal direction');
            player.currentTime = 3 * ANIMATION_DURATION + ANIMATION_DURATION / 4;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(ANIMATION_DURATION / 4), COMPUTED_STYLE_EPSILON,
                'Animation should be performed in normal direction');
            player.currentTime = 4 * ANIMATION_DURATION - 1;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(ANIMATION_DURATION - 1), COMPUTED_STYLE_EPSILON,
                'Animation should be performed in normal direction');
            doneCounter++;
            if (doneCounter === groups.length) {
                t.done();
            }
        }), t.unreached_func('Current ready promise should not be rejected'));
    });
}, 'Test that animation is performed in appropriate directions when animation is played ' +
    'in \'alternate-reverse\' direction and it\'s parent group in \'alternate\' direction');

async_test(function(t) {
    var animationTiming = {
        direction: 'reverse',
        duration: ANIMATION_DURATION,
        iterations: 2
    };
    var groupTiming = {
        direction: 'alternate-reverse',
        duration: ANIMATION_DURATION,
        iterations: 2
    };
    var animation = new Animation(createDiv(t), KEYFRAMES, animationTiming);
    var animationGroup = new AnimationGroup([animation], groupTiming);
    var animationSequence = new AnimationSequence([animation], groupTiming);
    var groups = [animationGroup, animationSequence];
    var doneCounter = 0;
    groups.forEach(function(group) {
        var player = document.timeline.play(group);

        assert_equals(animation.computedTiming.direction, 'reverse',
            'Wrong Animation.computedTiming.direction value');
        assert_equals(group.computedTiming.direction, 'alternate-reverse',
            'Wrong ' + type(group) + '.computedTiming.direction value');

        player.ready.then(t.step_func(function() {
            // First iteration of the group. Direction is normal.
            // For the first iteration of the animation direction is reversed
            player.currentTime = 1;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(ANIMATION_DURATION - 1), COMPUTED_STYLE_EPSILON,
                'Animation should be performed in reversed direction');
            player.currentTime = ANIMATION_DURATION / 4;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(ANIMATION_DURATION * 3 / 4), COMPUTED_STYLE_EPSILON,
                'Animation should be performed in reversed direction');
            player.currentTime = ANIMATION_DURATION - 1;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(1), COMPUTED_STYLE_EPSILON,
                   'Animation should be performed in reversed direction');

            // Second iteration of the animation. Direction is reversed
            player.currentTime = ANIMATION_DURATION + 1;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(ANIMATION_DURATION - 1), COMPUTED_STYLE_EPSILON,
                'Animation should be performed in reversed direction');
            player.currentTime = ANIMATION_DURATION + ANIMATION_DURATION / 4;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(ANIMATION_DURATION * 3 / 4), COMPUTED_STYLE_EPSILON,
                'Animation should be performed in reversed direction');
            player.currentTime = 2 * ANIMATION_DURATION - 1;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(1), COMPUTED_STYLE_EPSILON,
                'Animation should be performed in reversed direction');

            // Second iteration of the group. Direction is reversed.
            // So the second iteration of the animation goes first
            // For the second iteration of the animation direction is reversed
            // but normal because of the group
            player.currentTime = 2 * ANIMATION_DURATION + 1;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(1), COMPUTED_STYLE_EPSILON,
                'Animation should be performed in normal direction');
            player.currentTime = 2 * ANIMATION_DURATION + ANIMATION_DURATION / 4;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(ANIMATION_DURATION / 4), COMPUTED_STYLE_EPSILON,
                'Animation should be performed in normal direction');
            player.currentTime = 3 * ANIMATION_DURATION - 1;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(ANIMATION_DURATION - 1), COMPUTED_STYLE_EPSILON,
                'Animation should be performed in normal direction');

            // The first iteration of the animation. Direction is reversed
            // but normal because of the group
            player.currentTime = 3 * ANIMATION_DURATION + 1;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(1), COMPUTED_STYLE_EPSILON,
                'Animation should be performed in normal direction');
            player.currentTime = 3 * ANIMATION_DURATION + ANIMATION_DURATION / 4;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(ANIMATION_DURATION / 4), COMPUTED_STYLE_EPSILON,
                'Animation should be performed in normal direction');
            player.currentTime = 4 * ANIMATION_DURATION - 1;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(ANIMATION_DURATION - 1), COMPUTED_STYLE_EPSILON,
                'Animation should be performed in normal direction');
            doneCounter++;
            if (doneCounter === groups.length) {
                t.done();
            }
        }), t.unreached_func('Current ready promise should not be rejected'));
    });
}, 'Test that animation is performed in appropriate directions when animation is played ' +
    'in \'reverse\' direction and it\'s parent group in \'alternate-reverse\' direction');

async_test(function(t) {
    var animationTiming = {
        direction: 'alternate',
        duration: ANIMATION_DURATION,
        iterations: 2
    };
    var groupTiming = {
        direction: 'alternate-reverse',
        duration: ANIMATION_DURATION,
        iterations: 2
    };
    var animation = new Animation(createDiv(t), KEYFRAMES, animationTiming);
    var animationGroup = new AnimationGroup([animation], groupTiming);
    var animationSequence = new AnimationSequence([animation], groupTiming);
    var groups = [animationGroup, animationSequence];
    var doneCounter = 0;
    groups.forEach(function(group) {
        var player = document.timeline.play(group);

        assert_equals(animation.computedTiming.direction, 'alternate',
            'Wrong Animation.computedTiming.direction value');
        assert_equals(group.computedTiming.direction, 'alternate-reverse',
            'Wrong ' + type(group) + '.computedTiming.direction value');

        player.ready.then(t.step_func(function() {
            // First iteration of the group. Direction is normal.
            // For the first iteration of the animation direction is reversed
            player.currentTime = 1;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(ANIMATION_DURATION - 1), COMPUTED_STYLE_EPSILON,
                'Animation should be performed in reversed direction');
            player.currentTime = ANIMATION_DURATION / 4;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(ANIMATION_DURATION * 3 / 4), COMPUTED_STYLE_EPSILON,
                'Animation should be performed in reversed direction');
            player.currentTime = ANIMATION_DURATION - 1;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(1), COMPUTED_STYLE_EPSILON,
                   'Animation should be performed in reversed direction');

            // Second iteration of the animation. Direction is normal
            player.currentTime = ANIMATION_DURATION + 1;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(1), COMPUTED_STYLE_EPSILON,
                'Animation should be performed in normal direction');
            player.currentTime = ANIMATION_DURATION + ANIMATION_DURATION / 4;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(ANIMATION_DURATION / 4), COMPUTED_STYLE_EPSILON,
                'Animation should be performed in normal direction');
            player.currentTime = 2 * ANIMATION_DURATION - 1;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(ANIMATION_DURATION - 1), COMPUTED_STYLE_EPSILON,
                'Animation should be performed in normal direction');

            // Second iteration of the group. Direction is reversed.
            // So the second iteration of the animation goes first
            // For the second iteration of the animation direction is normal
            // but reversed because of the group
            player.currentTime = 2 * ANIMATION_DURATION + 1;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(ANIMATION_DURATION - 1), COMPUTED_STYLE_EPSILON,
                'Animation should be performed in reversed direction');
            player.currentTime = 2 * ANIMATION_DURATION + ANIMATION_DURATION / 4;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(ANIMATION_DURATION * 3 / 4), COMPUTED_STYLE_EPSILON,
                'Animation should be performed in reversed direction');
            player.currentTime = 3 * ANIMATION_DURATION - 1;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(1), COMPUTED_STYLE_EPSILON,
                'Animation should be performed in reversed direction');

            // The first iteration of the animation. Direction is reversed
            // but normal because of the group
            player.currentTime = 3 * ANIMATION_DURATION + 1;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(1), COMPUTED_STYLE_EPSILON,
                'Animation should be performed in normal direction');
            player.currentTime = 3 * ANIMATION_DURATION + ANIMATION_DURATION / 4;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(ANIMATION_DURATION / 4), COMPUTED_STYLE_EPSILON,
                'Animation should be performed in normal direction');
            player.currentTime = 4 * ANIMATION_DURATION - 1;
            assert_approx_equals(window.getComputedStyle(animation.target).top,
                getExpectedTop(ANIMATION_DURATION - 1), COMPUTED_STYLE_EPSILON,
                'Animation should be performed in normal direction');
            doneCounter++;
            if (doneCounter === groups.length) {
                t.done();
            }
        }), t.unreached_func('Current ready promise should not be rejected'));
    });
}, 'Test that animation is performed in appropriate directions when animation is played ' +
    'in \'alternate\' direction and it\'s parent group in \'alternate-reverse\' direction');
</script>
</body>
