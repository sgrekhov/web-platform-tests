<!DOCTYPE html>
<meta charset=utf-8>
<title>AnimationTiming fill attribute test</title>
<meta name="assert" content="The fill mode as specified by one of the FillMode enumeration values">
<link rel="help" href="http://w3c.github.io/web-animations/#dom-animationtiming-fill">
<link rel="author" title="Sergey G. Grekhov" href="mailto:sgrekhov@unipro.ru">
<script src="/resources/testharness.js"></script>
<script src="/resources/testharnessreport.js"></script>
<script src="../testcommon.js"></script>
<link rel="stylesheet" href="/resources/testharness.css">
<body>
<div id="log"></div>
<script>
function createAnimationsToTest(test, timing) {
    var animation1 = new Animation(createDiv(test), KEYFRAMES, timing);
    var animation2 = new Animation(createDiv(test), KEYFRAMES, ANIMATION_END_TIME);
    var animation3 = new Animation(createDiv(test), KEYFRAMES, ANIMATION_END_TIME);
    var animationGroup = new AnimationGroup([animation2], timing);
    var animationSequence = new AnimationSequence([animation3], timing);
    return [animation1, animation2, animation3];
}

async_test(function(t) {
    var timing = {
        fill: 'none',
        duration: ANIMATION_END_TIME
    };
    var animations = createAnimationsToTest(t, timing);
    animations.forEach(function(animation, index) {
        var node = animation;
        if (animation.parent !== null) {
            node = node.parent;
        }
        var player = document.timeline.play(node);

        player.ready.then(t.step_func(function() {
            player.currentTime = -10;
            assert_equals(window.getComputedStyle(animation.target), ANIMATION_TOP_DEFAULT,
                'Animation ' + type(node) + ' should not be in effect in before phase');
            player.currentTime = 100;
            assert_approx_equals(window.getComputedStyle(animation.target).top, getExpectedTop(100),
                COMPUTED_STYLE_EPSILON, 'Animation ' + type(node) + ' should be in effect');
            player.currentTime = ANIMATION_END_TIME + 10;
            assert_equals(window.getComputedStyle(animation.target), ANIMATION_TOP_DEFAULT,
                'Animation ' + type(node) + ' should not be in effect in after phase');
        }), t.unreached_func('Current ready promise should not be rejected'));
    });
}, 'Test that setting AnimationTiming.fill to \'none\' removes animation effects in before and ' +
    'after phases');

async_test(function(t) {
    var timing = {
        fill: 'forwards',
        duration: ANIMATION_END_TIME
    };
    var animations = createAnimationsToTest(t, timing);
    animations.forEach(function(animation, index) {
        var node = animation;
        if (animation.parent !== null) {
            node = node.parent;
        }
        var player = document.timeline.play(node);

        player.ready.then(t.step_func(function() {
            player.currentTime = -10;
            assert_equals(window.getComputedStyle(animation.target), ANIMATION_TOP_DEFAULT,
                'Animation ' + type(node) + ' should not be in effect in before phase');
            player.currentTime = 100;
            assert_approx_equals(window.getComputedStyle(animation.target).top, getExpectedTop(100),
                COMPUTED_STYLE_EPSILON, 'Animation ' + type(node) + ' should be in effect');
            player.currentTime = ANIMATION_END_TIME + 10;
            assert_equals(window.getComputedStyle(animation.target), ANIMATION_TOP_1,
                'Animation ' + type(node) + ' should hung on end in after phase');
        }), t.unreached_func('Current ready promise should not be rejected'));
    });
}, 'Test that setting AnimationTiming.fill to \'forwards\' removes animation effects in before phase ' +
    'and animation hungs on end');

async_test(function(t) {
    var timing = {
        fill: 'backwards',
        duration: ANIMATION_END_TIME
    };
    var animations = createAnimationsToTest(t, timing);
    animations.forEach(function(animation, index) {
        var node = animation;
        if (animation.parent !== null) {
            node = node.parent;
        }
        var player = document.timeline.play(node);

        player.ready.then(t.step_func(function() {
            player.currentTime = -10;
            assert_equals(window.getComputedStyle(animation.target), ANIMATION_TOP_0,
                'Animation ' + type(node) + ' should be on 0 time');
            player.currentTime = 100;
            assert_approx_equals(window.getComputedStyle(animation.target).top, getExpectedTop(100),
                COMPUTED_STYLE_EPSILON, 'Animation ' + type(node) + ' should be in effect');
            player.currentTime = ANIMATION_END_TIME + 10;
            assert_equals(window.getComputedStyle(animation.target), ANIMATION_TOP_DEFAULT,
                'Animation ' + type(node) + ' effect should be removed');
        }), t.unreached_func('Current ready promise should not be rejected'));
    });
}, 'Test that setting AnimationTiming.fill to \'backwards\' removes animation effects in after phase ' +
    'and animation hungs on 0 in before phase');

async_test(function(t) {
    var timing = {
        fill: 'both',
        duration: ANIMATION_END_TIME
    };
    var animations = createAnimationsToTest(t, timing);
    animations.forEach(function(animation, index) {
        var node = animation;
        if (animation.parent !== null) {
            node = node.parent;
        }
        var player = document.timeline.play(node);

        player.ready.then(t.step_func(function() {
            player.currentTime = -10;
            assert_equals(window.getComputedStyle(animation.target), ANIMATION_TOP_0,
                'Animation ' + type(node) + ' effect should be on 0 time');
            player.currentTime = 100;
            assert_approx_equals(window.getComputedStyle(animation.target).top, getExpectedTop(100),
                COMPUTED_STYLE_EPSILON, 'Animation ' + type(node) + ' should be in effect');
            player.currentTime = ANIMATION_END_TIME + 10;
            assert_equals(window.getComputedStyle(animation.target), ANIMATION_TOP_1,
                'Animation ' + type(node) + ' effect should be on end time');
        }), t.unreached_func('Current ready promise should not be rejected'));
    });
}, 'Test that setting AnimationTiming.fill to \'both\' hungs animation effects on zero and ' +
    'end time in before and after phases');

async_test(function(t) {
    var target = createDiv(t);
    var animation = new Animation(target, KEYFRAMES, ANIMATION_END_TIME);
    var player = document.timeline.play(animation);

    assert_equals(animation.computedTiming.fill, 'auto',
        'AnimationNode.computedTiming.fill should return \'auto\'');

    player.ready.then(t.step_func(function() {
        player.currentTime = -10;
        assert_equals(window.getComputedStyle(target), ANIMATION_TOP_DEFAULT,
            'Animation should not be in effect in before phase');
        player.currentTime = 100;
        assert_approx_equals(window.getComputedStyle(target).top, getExpectedTop(100),
            COMPUTED_STYLE_EPSILON, 'Animation should be in effect');
        player.currentTime = ANIMATION_END_TIME + 10;
        assert_equals(window.getComputedStyle(target), ANIMATION_TOP_DEFAULT,
            'Animation should not be in effect in after phase');
    }), t.unreached_func('Current ready promise should not be rejected'));
}, 'Test that default fill value of the Animation is \'auto\' and ' +
    'it is treated as \'none\' for animation purposes');

async_test(function(t) {
    var timing = {
        fill: 'auto',
        duration: ANIMATION_END_TIME
    };
    var target = createDiv(t);
    var animation = new Animation(target, KEYFRAMES, timing);
    var player = document.timeline.play(animation);

    assert_equals(animation.computedTiming.fill, 'auto',
        'AnimationNode.computedTiming.fill should return \'auto\'');

    player.ready.then(t.step_func(function() {
        player.currentTime = -10;
        assert_equals(window.getComputedStyle(target), ANIMATION_TOP_DEFAULT,
            'Animation should not be in effect in before phase');
        player.currentTime = 100;
        assert_approx_equals(window.getComputedStyle(target).top, getExpectedTop(100),
            COMPUTED_STYLE_EPSILON, 'Animation should be in effect');
        player.currentTime = ANIMATION_END_TIME + 10;
        assert_equals(window.getComputedStyle(target), ANIMATION_TOP_DEFAULT,
            'Animation should not be in effect in after phase');
    }), t.unreached_func('Current ready promise should not be rejected'));
}, 'Test that fill value \'auto\' of the Animation is  treated as \'none\' for animation purposes');

async_test(function(t) {
    var target1 = createDiv(t);
    var target2 = createDiv(t);
    var animation1 = new Animation(target1, KEYFRAMES, ANIMATION_END_TIME);
    var animation2 = new Animation(target2, KEYFRAMES, {delay: 50, duration: ANIMATION_END_TIME});
    var animationGroup = new AnimationGroup([animation1, animation2], {delay: 50, duration: ANIMATION_END_TIME});
    var player = document.timeline.play(animationGroup);

    assert_equals(animationGroup.computedTiming.fill, 'auto',
        'AnimationNode.computedTiming.fill should return \'auto\'');

    player.ready.then(t.step_func(function() {
        player.currentTime = -10;
        // animationGroup active time should be 0
        assert_equals(window.getComputedStyle(target1), ANIMATION_TOP_0,
            'Animation1 should be in effect in before phase');
        assert_equals(window.getComputedStyle(target2), ANIMATION_TOP_DEFAULT,
            'Animation2 should not be in effect in before phase');
        player.currentTime = 10;
        // animationGroup active time should still be 0 because of start delay
        assert_equals(window.getComputedStyle(target1), ANIMATION_TOP_0,
            'Animation1 should be in effect in before phase');
        assert_equals(window.getComputedStyle(target2), ANIMATION_TOP_DEFAULT,
            'Animation2 should not be in effect in before phase');
        player.currentTime = 80;
        // animation1 should in active phase, animation2 still not in effect because of start delay
        assert_approx_equals(window.getComputedStyle(target1).top, getExpectedTop(30),
            COMPUTED_STYLE_EPSILON, 'Animation1 should be in effect');
        assert_equals(window.getComputedStyle(target2), ANIMATION_TOP_DEFAULT,
            'Animation2 should not be in effect in before phase');
        player.currentTime = 150;
        assert_approx_equals(window.getComputedStyle(target1).top, getExpectedTop(100),
            COMPUTED_STYLE_EPSILON, 'Animation1 should be in effect');
        assert_approx_equals(window.getComputedStyle(target2).top, getExpectedTop(50),
            COMPUTED_STYLE_EPSILON, 'Animation2 should be in effect');
        player.currentTime = ANIMATION_END_TIME + 10;
        assert_equals(window.getComputedStyle(target1), ANIMATION_TOP_1,
            'Animation1 should be in effect in after phase');
        assert_approx_equals(window.getComputedStyle(target2).top, getExpectedTop(ANIMATION_END_TIME - 40),
            COMPUTED_STYLE_EPSILON, 'Animation2 should be in effect in after phase');
        player.currentTime = ANIMATION_END_TIME + 200;
        assert_equals(window.getComputedStyle(target1), ANIMATION_TOP_1,
            'Animation1 should be in effect in after phase');
        assert_approx_equals(window.getComputedStyle(target2).top, getExpectedTop(ANIMATION_END_TIME - 40),
            COMPUTED_STYLE_EPSILON, 'Animation2 should be in effect in after phase');
    }), t.unreached_func('Current ready promise should not be rejected'));
}, 'Test that default fill value of the AnimationGroup is \'auto\' and ' +
    'it is treated as \'both\' for animation purposes');

async_test(function(t) {
    var target1 = createDiv(t);
    var target2 = createDiv(t);
    var animation1 = new Animation(target1, KEYFRAMES, ANIMATION_END_TIME);
    var animation2 = new Animation(target2, KEYFRAMES, {delay: 50, duration: ANIMATION_END_TIME});
    var animationSequence = new AnimationSequence([animation1, animation2],
        {delay: 50, duration: 2 * ANIMATION_END_TIME});
    var player = document.timeline.play(animationSequence);

    assert_equals(animationSequence.computedTiming.fill, 'auto',
        'AnimationNode.computedTiming.fill should return \'auto\'');

    player.ready.then(t.step_func(function() {
        player.currentTime = -10;
        assert_equals(window.getComputedStyle(target1), ANIMATION_TOP_0,
            'Animation1 should be in effect in before phase');
        assert_equals(window.getComputedStyle(target2), ANIMATION_TOP_DEFAULT,
            'Animation2 should not be in effect in before phase');
        player.currentTime = 10;
        assert_equals(window.getComputedStyle(target1), ANIMATION_TOP_0,
            'Animation1 should be in effect in before phase');
        assert_equals(window.getComputedStyle(target2), ANIMATION_TOP_DEFAULT,
            'Animation2 still should not be in effect in before phase');
        player.currentTime = 100;
        assert_approx_equals(window.getComputedStyle(target1).top, getExpectedTop(50),
            COMPUTED_STYLE_EPSILON, 'Animation should be in effect in active phase');
        assert_equals(window.getComputedStyle(target2), ANIMATION_TOP_DEFAULT,
            'Animation2 still should not be in effect in sequence active phase');
        player.currentTime = ANIMATION_END_TIME + 10;
        assert_equals(window.getComputedStyle(target1), ANIMATION_TOP_DEFAULT,
            'Animation1 should not be in effect in after phase');
        assert_equals(window.getComputedStyle(target2), ANIMATION_TOP_DEFAULT,
            'Animation2 still should not be in effect in sequence active phase');
        player.currentTime = ANIMATION_END_TIME + 100;
        assert_equals(window.getComputedStyle(target1), ANIMATION_TOP_DEFAULT,
            'Animation1 should not be in effect in after phase');
        assert_approx_equals(window.getComputedStyle(target2).top, getExpectedTop(50),
            COMPUTED_STYLE_EPSILON, 'Animation2 should be in effect');
        player.currentTime = 2 * ANIMATION_END_TIME + 10;
        assert_equals(window.getComputedStyle(target1), ANIMATION_TOP_DEFAULT,
            'Animation1 should not be in effect in after phase');
        assert_approx_equals(window.getComputedStyle(target2).top, getExpectedTop(ANIMATION_END_TIME - 50),
            COMPUTED_STYLE_EPSILON, 'Animation2 should be clipped and hold');
        player.currentTime = 2 * ANIMATION_END_TIME + 100;
        assert_equals(window.getComputedStyle(target1), ANIMATION_TOP_DEFAULT,
            'Animation1 should not be in effect in after phase');
        assert_approx_equals(window.getComputedStyle(target2).top, getExpectedTop(ANIMATION_END_TIME - 50),
            COMPUTED_STYLE_EPSILON, 'Animation2 should be clipped and hold');
    }), t.unreached_func('Current ready promise should not be rejected'));
}, 'Test that default fill value of the AnimationSequence is \'auto\' and ' +
    'it is treated as \'both\' for animation purposes');

async_test(function(t) {
    var target1 = createDiv(t);
    var target2 = createDiv(t);

    var animation1 = new Animation(target1, KEYFRAMES,
        {fill: 'none', duration: ANIMATION_END_TIME / 2});
    var animation2 = new Animation(target2, KEYFRAMES,
        {fill: 'none', delay: 50, duration: ANIMATION_END_TIME});
    var animationGroup = new AnimationGroup([animation1, animation2], {fill: 'none', delay: 50});
    var player = document.timeline.play(animationGroup);

    assert_equals(animationGroup.computedTiming.fill, 'auto',
        'AnimationNode.computedTiming.fill should return \'auto\'');

    player.ready.then(t.step_func(function() {
        player.currentTime = -10;
        assert_equals(window.getComputedStyle(target1), ANIMATION_TOP_DEFAULT,
            'Animation1 should not be in effect in before phase');
        assert_equals(window.getComputedStyle(target2), ANIMATION_TOP_DEFAULT,
            'Animation2 should not be in effect in before phase');
        player.currentTime = 10;
        assert_equals(window.getComputedStyle(target1), ANIMATION_TOP_DEFAULT,
            'Animation1 should be in effect in before phase');
        assert_equals(window.getComputedStyle(target2), ANIMATION_TOP_DEFAULT,
            'Animation2 should not be in effect in before phase');
        player.currentTime = 80;
        // animation1 should in active phase, animation2 still not in effect because of start delay
        assert_approx_equals(window.getComputedStyle(target1).top, getExpectedTop(30),
            COMPUTED_STYLE_EPSILON, 'Animation1 should be in effect');
        assert_equals(window.getComputedStyle(target2), ANIMATION_TOP_DEFAULT,
            'Animation2 should not be in effect in before phase');
        player.currentTime = 150;
        assert_approx_equals(window.getComputedStyle(target1).top, getExpectedTop(100),
            COMPUTED_STYLE_EPSILON, 'Animation1 should be in effect');
        assert_approx_equals(window.getComputedStyle(target2).top, getExpectedTop(50),
            COMPUTED_STYLE_EPSILON, 'Animation2 should be in effect');
        player.currentTime = ANIMATION_END_TIME / 2 + 10;
        assert_equals(window.getComputedStyle(target1), ANIMATION_TOP_DEFAULT,
            'Animation1 should be in effect in after phase');
        assert_approx_equals(window.getComputedStyle(target2).top,
            getExpectedTop(ANIMATION_END_TIME /2 - 40), COMPUTED_STYLE_EPSILON,
            'Animation2 should be in effect in after phase');
        player.currentTime = ANIMATION_END_TIME + 100;
        assert_equals(window.getComputedStyle(targe1t), ANIMATION_TOP_DEFAULT,
            'Animation1 should be in effect in after phase');
        assert_equals(window.getComputedStyle(target2), ANIMATION_TOP_DEFAULT,
            'Animation2 should be in effect in after phase');
    }), t.unreached_func('Current ready promise should not be rejected'));
}, 'Animation group containing two animations, short and long one. Fill mode is ' +
    '\'none\' for both animations and the group. Test that animation effect is in ' +
    'effect on active phases only');
// TODO add tests like the one above but for other modes for group and animations
</script>
</body>
