<!DOCTYPE html>
<meta charset=utf-8>
<title>AnimationGroup computedTiming attribute test</title>
<meta name="assert" content="Returns the calculated timing properties for this animation node">
<link rel="help" href="http://w3c.github.io/web-animations/#dom-animationnode-computedtiming">
<link rel="author" title="Sergey G. Grekhov" href="mailto:sgrekhov@unipro.ru">
<link rel="author" title="Aleksei Yu. Semenov" href="mailto:a.semenov@unipro.ru">
<script src="/resources/testharness.js"></script>
<script src="/resources/testharnessreport.js"></script>
<script src="../testcommon.js"></script>
<link rel="stylesheet" href="/resources/testharness.css">
<body>
<div id="log"></div>
<script>
// Test here only cases specific to AnimationGroup
// The rest is tested in animation-node-computed-timing.html
test(function() {
    var node = new AnimationGroup([]);
    assert_equals(node.computedTiming.duration, 0,
        'AnimationGroup.computedTiming.duration should return zero');
}, 'Test AnimationGroup.computedTiming.duration initial value is intrinsic ' +
    'iteration duration, which is zero for group without children');

test(function() {
    var node = new Animation(createDiv(this), KEYFRAMES, ANIMATION_DURATION);
    var group = new AnimationGroup([node]);
    assert_equals(group.computedTiming.duration, node.computedTiming.endTime,
        'AnimationGroup.computedTiming.duration should return intrinsic iteration duration');
}, 'Test AnimationGroup.computedTiming.duration initial value is intrinsic ' +
    'iteration duration, which is max(0, maximum end time of children) ' +
    'for group with single child');

test(function() {
    var valuesToTest = [-1, -1000, -0.5, -Number.MAX_VALUE, Number.NaN, -Infinity, 'one'];
    valuesToTest.forEach(function(durationValue) {
        var timing = {duration: durationValue};
        var node = new Animation(createDiv(this), KEYFRAMES, ANIMATION_DURATION);
        var group = new AnimationGroup([node]);

        assert_equals(group.computedTiming.duration, node.computedTiming.endTime,
            'AnimationGroup.computedTiming.duration should return ' +
            ' max(0, maximum end time of children) for value ' + durationValue);
    }
}, 'Test AnimationGroup.computedTiming.duration returns intrinsic iteration duration ' +
    'for nodes with negative, NaN and string values');

test(function() {
    var node1 = new Animation(createDiv(this), [], ANIMATION_DURATION);
    var node2 = new Animation(createDiv(this), [], ANIMATION_DURATION / 2);
    var group = new AnimationGroup([node1, node2]);
    assert_equals(group.computedTiming.duration, node1.computedTiming.endTime,
        'AnimationGroup.computedTiming.duration should return intrinsic iteration duration');
}, 'Test AnimationGroup.computedTiming.duration initial value is intrinsic ' +
    'iteration duration, which is max(0, maximum end time of children) ' +
    'for group several children');

test(function() {
    var node1 = new AnimationGroup([], -1 * ANIMATION_DURATION);
    var node2 = new AnimationGroup([], -1 * ANIMATION_DURATION / 2);
    var group = new AnimationGroup([node1, node2]);
    assert_equals(group.computedTiming.duration, 0,
        'AnimationGroup.computedTiming.duration should return zero');
}, 'Test AnimationGroup.computedTiming.duration initial value is intrinsic ' +
    'iteration duration, which is max(0, maximum end time of children) ' +
    'for group with children with negative end time');

test(function() {
    var timing = {duration: 'auto'};
    var node = new AnimationGroup([], timing);
    assert_equals(node.computedTiming.duration, 0,
        'AnimationGroup.computedTiming.duration should return zero');
}, 'Test AnimationGroup.computedTiming.duration return intrinsic ' +
    'iteration duration, which is zero for group without children, ' +
    'if group timing.duration is \'auto\'');

test(function() {
    var timing = {duration: 'auto'};
    var node = new Animation(createDiv(this), KEYFRAMES, ANIMATION_DURATION);
    var group = new AnimationGroup([node], timing);
    assert_equals(group.computedTiming.duration, node.computedTiming.endTime,
        'AnimationGroup.computedTiming.duration should return intrinsic iteration duration');
}, 'Test AnimationGroup.computedTiming.duration returns intrinsic ' +
    'iteration duration, which is max(0, maximum end time of children) ' +
    'for group with single child and group timing.duration is \'auto\'');

test(function() {
    var timing = {duration: 'auto'};
    var node1 = new Animation(createDiv(this), [], ANIMATION_DURATION);
    var node2 = new Animation(createDiv(this), [], ANIMATION_DURATION / 2);
    var group = new AnimationGroup([node1, node2], timing);
    assert_equals(group.computedTiming.duration, node1.computedTiming.endTime,
        'AnimationGroup.computedTiming.duration should return intrinsic iteration duration');
}, 'Test AnimationGroup.computedTiming.duration returns intrinsic ' +
    'iteration duration, which is max(0, maximum end time of children) ' +
    'for group several children and group timing.duration is \'auto\'');

test(function() {
    var timing = {duration: 'auto'};
    var node1 = new AnimationGroup([], -1 * ANIMATION_DURATION);
    var node2 = new AnimationGroup([], -1 * ANIMATION_DURATION / 2);
    var group = new AnimationGroup([node1, node2], timing);
    assert_equals(group.computedTiming.duration, 0,
        'AnimationGroup.computedTiming.duration should return zero');
}, 'Test AnimationGroup.computedTiming.duration returns intrinsic ' +
    'iteration duration, which is max(0, maximum end time of children) ' +
    'for group with children with negative end time and group timing.duration is \'auto\'');

test(function() {
    var timing = {duration: 'some unsupported value'};
    var node = new AnimationGroup([], timing);
    assert_equals(node.computedTiming.duration, 0,
        'AnimationGroup.computedTiming.duration should return zero');
}, 'Test AnimationGroup.computedTiming.duration return intrinsic ' +
    'iteration duration, which is zero for group without children, ' +
    'if group timing.duration value is unsupported');

test(function() {
    var timing = {duration: 'some unsupported value'};
    var node = new Animation(createDiv(this), KEYFRAMES, ANIMATION_DURATION);
    var group = new AnimationGroup([node], timing);
    assert_equals(group.computedTiming.duration, node.computedTiming.endTime,
        'AnimationGroup.computedTiming.duration should return intrinsic iteration duration');
}, 'Test AnimationGroup.computedTiming.duration returns intrinsic ' +
    'iteration duration, which is max(0, maximum end time of children) ' +
    'for group with single child and group timing.duration value is unsupported');

test(function() {
    var timing = {duration: 'some unsupported value'};
    var node1 = new Animation(createDiv(this), [], ANIMATION_DURATION);
    var node2 = new Animation(createDiv(this), [], ANIMATION_DURATION / 2);
    var group = new AnimationGroup([node1, node2], timing);
    assert_equals(group.computedTiming.duration, node1.computedTiming.endTime,
        'AnimationGroup.computedTiming.duration should return intrinsic iteration duration');
}, 'Test AnimationGroup.computedTiming.duration returns intrinsic ' +
    'iteration duration, which is max(0, maximum end time of children) ' +
    'for group with several children and group timing.duration value is unsupported');

test(function() {
    var timing = {duration: 'some unsupported value'};
    var node1 = new AnimationGroup([], -1 * ANIMATION_DURATION);
    var node2 = new AnimationGroup([], -1 * ANIMATION_DURATION / 2);
    var group = new AnimationGroup([node1, node2], timing);
    assert_equals(group.computedTiming.duration, 0,
        'AnimationGroup.computedTiming.duration should return zero');
}, 'Test AnimationGroup.computedTiming.duration returns intrinsic ' +
    'iteration duration, which is max(0, maximum end time of children) ' +
    'for group with children with negative end time and group timing.duration value is unsupported');

test(function() {
    var node = new AnimationGroup([]);
    assert_equals(node.computedTiming.fill, 'both',
        'AnimationGroup.computedTiming.fill should return \'both\'');
}, 'Test AnimationGroup.computedTiming.fill default value is \'both\');

test(function() {
    var timing = {fill: 'auto'};
    var node = new AnimationGroup([], timing);

    assert_equals(node.computedTiming.fill, \'both\',
        'AnimationGroup.computedTiming.fill should return \'both\'');
}, 'Test AnimationGroup.computedTiming.fill returns \'both\' ' +
    'for nodes with timing.fill value \'auto\'');
</script>
</body>