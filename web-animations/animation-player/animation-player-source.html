<!DOCTYPE html>
<meta charset=utf-8>
<title>AnimationPlayer source attribute test</title>
<meta name="assert" content="The source content associated with this player. Setting this attribute updates the objectâ€™s source content using the procedure to set the source content of a player">
<link rel="help" href="http://w3c.github.io/web-animations/#dom-animationplayer-source">
<link rel="author" title="Sergey G. Grekhov" href="mailto:sgrekhov@unipro.ru">
<link rel="author" title="Aleksei Yu. Semenov" href="mailto:a.semenov@unipro.ru">
<script src="/resources/testharness.js"></script>
<script src="/resources/testharnessreport.js"></script>
<script src="../testcommon.js"></script>
<link rel="stylesheet" href="/resources/testharness.css">
<body>
<div id="log"></div>
<script>
test(function() {
    var animation = newAnimation(createDiv(this));
    var player = document.timeline.play(animation);

    assert_equals(player.source, animation, 'AnimationPlayer.source ' +
        'attribute value should be the value passed to the AnimationTimeline.play()');
}, 'Test AnimationPlayer.source attribute value is the value passed ' +
    'to the AnimationTimeline.play()');

test(function() {
    var animation = newAnimation(createDiv(this));
    var player = new AnimationPlayer(animation);

    assert_equals(player.source, animation, 'AnimationPlayer.source ' +
        'attribute value should be the value passed to the constructor');
}, 'Test AnimationPlayer.source attribute value is the value passed ' +
    'to the AnimationPlayer constructor');

test(function() {
    var animation = newAnimation(createDiv(this));
    var player = new AnimationPlayer();
    player.source = animation;

    assert_equals(player.source, animation, 'AnimationPlayer.source ' +
        'attribute value should be set');
}, 'Test setting value of AnimationPlayer.source attribute. Previous value of ' +
    'the attribute is null');

test(function() {
    var oldSource = newAnimation(createDiv(this));
    var newSource = newAnimation(createDiv(this));
    var player = new AnimationPlayer(oldSource);
    player.source = newSource;

    assert_equals(player.source, newsource, 'AnimationPlayer.source ' +
        'attribute value should be set');
}, 'Test setting value of AnimationPlayer.source attribute. Previous value of ' +
    'the attribute is not null');

test(function() {
    var parent = new AnimationGroup([newAnimation(createDiv(this)),
        new AnimationGroup([]), new AnimationSequence([])]);
    for (var i = 0; i < parent.children.length; i++) {
        var player = new AnimationPlayer();
        player.source = parent.children[i];

        assert_equals(player.source, parent.children[i], 'Source of newly created player ' +
            'should be set for child ' + i);
        assert_equals(parent.children[i].parent, null, 'Source should be removed from ' +
            'its parent animation group for child ' + i);
    }
    assert_array_equals(parent.children, [], 'Source should be removed from the parent ' +
        'group\'s children');
}, 'Test that setting value of AnimationPlayer.source attribute removes new source ' +
    'from its parent group');

test(function() {
    var source = newAnimation(createDiv(this));
    var player = document.timeline.play(source);
    var readyPromise = player.ready;
    player.source = source;

    // FIXME How to check that nothing was changed? Here we check that
    // current ready promise was not changed. But probably this is not enough
    assert_object_equals(player.ready, readyPromise, 'Player\'s current ready promise ' +
        'should not be changed');
}, 'Test that setting value of source attribute to the same value as old one does nothing');

test(function() {
    var source1 = newAnimation(createDiv(this));
    var source2 = newAnimation(createDiv(this));
    var player1 = document.timeline.play(source1);
    var player2 = document.timeline.play(source2);

    player1.source = source2;

    assert_equals(player2.source, null, 'New source content should be unbind from previous plsyer');
}, 'Test that if new content is not null and if new content is the source content of another player ' +
    'then source content of the previous player should be set to null');

async_test(function(t) {
    var player = document.timeline.play(newAnimation(createDiv(this)));
    var readyPromise = player.ready;

    player.ready.then(
        //onFulfilled. This never should called because we are going to reject
        // current ready promise and cancel pending play task
        t.unreached_func('Current ready promise should be rejected'),
        // onRejected. Should be called with AbortError
        t.step_func(function(error) {
            assert_class_string(error, 'AbortError', 'Promise should be rejected ' +
                'with a DOMException named \'AbortError\'');
            t.done();
        }));

    player.source = null;
    assert_not_equals(player.ready, readyPromise, 'Player\'s current ready promise ' +
        'should be a new resolved Promise object');
}, 'Test that setting value of AnimationPlayer.source attribute to null ' +
    'resets a player\'s pending tasks');

async_test(function(t) {
    var oldSource = newAnimation(createDiv(t));
    var newSource = newAnimation(createDiv(t));
    var player = document.timeline.play(oldSource);
    player.pause();
    player.source = newSource;

    player.ready.then(t.step_func(function() {
        assert_equals(player.source, newSource, 'Player should play new source content');
        assert_equals(player.playState, 'paused', 'Paused task should not be canceled');
        t.done();
    }), t.unreached_func('Current ready promise should not be rejected'));
}, 'Test that setting value of AnimationPlayer.source attribute to new value ' +
    'reschedules player\'s pending play and pause tasks');

async_test(function(t) {
    var oldSource = newAnimation(createDiv(t));
    var newSource = newAnimation(createDiv(t));
    var player = document.timeline.play(oldSource);
    player.finish();
    player.source = newSource;

    player.ready.then(t.step_func(function() {
        assert_equals(player.source, newSource, 'Player should play new source content');
        assert_equals(player.playState, 'finished', 'Player finished state ' +
            'should be preserved');
        t.done();
    }), t.unreached_func('Current ready promise should not be rejected'));
}, 'Test that setting value of AnimationPlayer.source attribute to new value ' +
    'does not change player finished state');

async_test(function(t) {
    var oldSource = newAnimation(createDiv(t));
    var newSource = newAnimation(createDiv(t));
    var player = document.timeline.play(oldSource);
    player.source = newSource;

    player.ready.then(t.step_func(function() {
        player.currentTime = ANIMATION_END_TIME/2;
        assert_equals(window.getComputedStyle(newSource.target).top, ANIMATION_TOP_0_5,
            'Animation should take place for the new source content');
        assert_equals(window.getComputedStyle(oldSource.target).top, ANIMATION_TOP_DEFAULT,
            'Animation should not take place for the old source content');
        t.done();
    }), t.unreached_func('Current ready promise should not be rejected'));
}, 'Test that after setting value of AnimationPlayer.source attribute to new value ' +
    'animation takes place on new source content');

async_test(function(t) {
    var numOfCallsNullTime = 0;
    var oldSource = new Animation(createDiv(t),
        function(timeFraction, currentTarget, animationObject) {
            if (timeFraction === null) {
                numOfCallsNullTime++;
            }
        }, 100);
    var newSource = newAnimation(createDiv(this));
    var player = document.timeline.play(oldSource);

    player.ready.then(t.step_func(function() {
        setTimeout(function() {
            t.step(function() {
                assert_equals(numOfCallsNullTime, 1, 'AnimationEffect callback should ' +
                    'be called with null timeFraction after changing of player source');
                t.done();
            });
        }, 50);
    }), t.unreached_func('Current ready promise should not be rejected'));
}, 'Test that EffectCallback is called with null timeFraction ' +
    'if player source is changed');

async_test(function(t) {
    var oldSource = newAnimation(createDiv(t));
    var newSource = newAnimation(createDiv(t));
    var player = document.timeline.play(oldSource);

    player.ready.then(t.step_func(function() {
        player.currentTime = ANIMATION_END_TIME / 2;
        player.source = newSource;
        player.ready.then(t.step_func(function() {
            assert_equals(window.getComputedStyle(newSource.target).top, ANIMATION_TOP_0_5,
                'Animation should take place for the new source content');
            t.done();
        }), t.unreached_func('Current ready promise should not be rejected'));
    }));
}, 'Test that after setting value of AnimationPlayer.source attribute to new value ' +
    'goes on new animation from the same position');

async_test(function(t) {
    var oldSource = new Animation(createDiv(t), KEYFRAMES, 1000);
    var newSource = new Animation(createDiv(t), KEYFRAMES, 400);
    var player = document.timeline.play(oldSource);

    player.ready.then(t.step_func(function() {
        player.currentTime = 500;
        player.source = newSource;
        player.ready.then(t.step_func(function() {
            assert_equals(player.playState, 'finished', 'Player should be finished');
            t.done();
        }));
    }), t.unreached_func('Current ready promise should not be rejected'));
}, 'Test that after setting value of AnimationPlayer.source attribute to new value ' +
    'finishes player if current time exceeds source duration');

async_test(function(t) {
    var player = document.timeline.play(null);
    var currentTime = ANIMATION_END_TIME / 2;
    player.currentTime = currentTime;
    var source = newAnimation(createDiv(t));
    player.source = source;

    player.ready.then(t.step_func(function() {
        assert_equals(player.currentTime, currentTime, 'Player should start playing of ' +
            'new source content from players\'s current time');
        t.done();
    }), t.unreached_func('Current ready promise should not be rejected'));
}, 'Player should start playing of new source content from players\'s current time');
</script>
</body>
