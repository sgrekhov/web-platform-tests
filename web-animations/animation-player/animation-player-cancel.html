<!DOCTYPE html>
<meta charset=utf-8>
<title>Animation player cancel method test</title>
<meta name="assert" content="Clears all effects caused by this player and aborts its playback by running the cancel a player procedure for this object">
<link rel="help" href="http://w3c.github.io/web-animations/#dom-animationplayer-cancel">
<link rel="author" title="Sergey G. Grekhov" href="mailto:sgrekhov@unipro.ru">
<script src="/resources/testharness.js"></script>
<script src="/resources/testharnessreport.js"></script>
<script src="../testcommon.js"></script>
<link rel="stylesheet" href="/resources/testharness.css">
<body>
<div id="log"></div>
<script>
async_test(function(t) {
    var player = document.timeline.play(new Animation(createDiv(t), KEYFRAMES, ANIMATION_DURATION));
    var readyPromise = player.ready;
    var finishedPromise = player.finished;

    player.ready.then(t.unreached_func('Current ready promise should be rejected'),
        t.step_func(function(error) {
            assert_class_string(error, 'AbortError', 'Promise should be rejected ' +
                'with a DOMException named \'AbortError\'');
            return player.ready;
        }).then(t.step_func(function() {
            assert_equals(player.startTime, null, 'Player start time should be unresolved');
            assert_not_equals(player.ready, readyPromise, 'Current ready promise should be a ' +
                'new Promise object');
            assert_not_equals(player.finished, finishedPromise, 'Current finished promise ' +
                'should be a new Promise object');
            assert_equals(player.playState, 'idle', 'Player should be in idle state');
            t.done();
        }), t.unreached_func('Current ready promise should be rejected')));

    player.finished.then(t.unreached_func('Current finished promise should be rejected'),
        t.step_func(function(error) {
                assert_class_string(error, 'AbortError', 'Promise should be rejected ' +
                    'with a DOMException named \'AbortError\'');
        }));
    player.cancel();
}, 'Test that AnimationPlayer.cancel() method rejects current ready and finished promises, ' +
    'makes start time unresolved and replaces ready and finished promises by new Promise ' +
    'objects');

async_test(function(t) {
    var numOfCallsNullTime = 0;
    var source = new Animation(createDiv(t),
        function(timeFraction, currentTarget, animationObject) {
            if (timeFraction === null) {
                numOfCallsNullTime++;
            }
        }, 100);
    var player = document.timeline.play(source);

    player.ready.then(t.step_func(function() {
        player.cancel();
        setTimeout(function() {
            t.step(function() {
                assert_equals(numOfCallsNullTime, 1, 'AnimationEffect callback should ' +
                    'be called with null timeFraction after cancelling of the player');
                t.done();
            });
        }, 50);
    }), t.unreached_func('Current ready promise should not be rejected'));
}, 'Test that EffectCallback is called with null timeFraction ' +
    'if player is cancelled');

async_test(function(t) {
    var source = new Animation(createDiv(t), KEYFRAMES, ANIMATION_DURATION);
    var player = document.timeline.play(source);

    player.ready.then(t.step_func(function() {
        player.currentTime = ANIMATION_DURATION/2;
        player.cancel();

        assert_equals(window.getComputedStyle(source.target).top, ANIMATION_TOP_DEFAULT,
            'Animation should not take place for the old source content');
        t.done();
    }), t.unreached_func('Current ready promise should not be rejected'));
}, 'Test that AnimationPlayer.cancel() method removes all animation effects');
</script>
</body>
