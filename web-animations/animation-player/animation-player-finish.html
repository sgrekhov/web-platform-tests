<!DOCTYPE html>
<meta charset=utf-8>
<title>AnimationPlayer finish method tests</title>
<meta name="assert" content="Seeks the player to the end of the source content in the current direction by running the finish a player procedure for this object">
<link rel="help" href="http://w3c.github.io/web-animations/#dom-animationplayer-finish">
<link rel="help" href="http://w3c.github.io/web-animations/#finish-a-player">
<link rel="author" title="Sergey G. Grekhov" href="mailto:sgrekhov@unipro.ru">
<link rel="author" title="Aleksei Yu. Semenov" href="mailto:a.semenov@unipro.ru">
<script src="/resources/testharness.js"></script>
<script src="/resources/testharnessreport.js"></script>
<script src="../testcommon.js"></script>
<link rel="stylesheet" href="/resources/testharness.css">
<body>
<div id="log"></div>
<script>
async_test(function(t) {
    var player = newAnimationPlayer(createDiv(t));

    player.ready.then(t.step_func(function() {
        player.playbackRate = 0;
        assert_throws('InvalidStateError', function() {
            player.finish();
        }, 'InvalidStateError should be thrown if playback rate is 0');
        t.done();
    }), t.unreached_func('Current ready promise should not be rejected'));
}, 'AnimationPlayer.finish() throws InvalidStateError if playback rate is 0');

async_test(function(t) {
    var animation = new Animation(createDiv(t), KEYFRAMES, {iterations: Number.POSITIVE_INFINITY});
    var player = document.timeline.play(animation);

    player.ready.then(t.step_func(function() {
        assert_throws('InvalidStateError', function() {
            player.finish();
        }, 'InvalidStateError should be thrown if playback rate is > 0 and ' +
            'the end time of this player\'s source content is infinity');
        t.done();
    }), t.unreached_func('Current ready promise should not be rejected'));
}, 'AnimationPlayer.finish() throws InvalidStateError if playback rate > 0 and ' +
    'the end time of this player\'s source content is infinity');

async_test(function(t) {
    var player = newAnimationPlayer(createDiv(t));

    player.ready.then(t.step_func(function() {
        player.finish();
        assert_equals(player.currentTime, ANIMATION_DURATION,
            'AnimationPlayer.finish() should seek current time to the end time');
        t.done();
    }), t.unreached_func('Current ready promise should not be rejected'));
}, 'AnimationPlayer.finish() method seeks current time to the source content end time');

async_test(function(t) {
    var player = newAnimationPlayer(createDiv(t));
    player.currentTime = ANIMATION_DURATION / 2;
    player.playbackRate = -1;

    player.ready.then(t.step_func(function() {
        player.finish();
        assert_equals(player.currentTime, 0, 'AnimationPlayer.finish() should seek ' +
            'current time to the 0 if playback rate < 0');
        t.done();
    }), t.unreached_func('Current ready promise should not be rejected'));
}, 'AnimationPlayer.finish() method seeks current time to 0 if playback rate < 0');

async_test(function(t) {
    var player = newAnimationPlayer(createDiv(t));

    player.ready.then(t.step_func(function() {
        player.finish();
        assert_equals(player.playState, 'finished',  'AnimationPlayer.finish() should ' +
            'change play state to finished if player is not paused');
        t.done();
    }), t.unreached_func('Current ready promise should not be rejected'));
}, 'AnimationPlayer.finish() changes play state to finished if player is not paused');

async_test(function(t) {
    var player = newAnimationPlayer(createDiv(t));

    player.ready.then(t.step_func(function() {
        player.playbackRate = 2;
        player.finish();
        var expectedStartTime = player.timeline.currentTime -
            ANIMATION_DURATION / player.playbackRate;
        assert_equals(player.startTime, expectedStartTime,  'AnimationPlayer.finish() should ' +
            'update player\'s start time');
        t.done();
    }), t.unreached_func('Current ready promise should not be rejected'));
}, 'AnimationPlayer.finish() updates player\'s start time to ' +
    'timeline time - source content end / player playback rate if playback rate > 0');

async_test(function(t) {
    var player = newAnimationPlayer(createDiv(t));

    player.ready.then(t.step_func(function() {
        player.playbackRate = -2;
        player.finish();
        var expectedStartTime = player.timeline.currentTime;
        assert_equals(player.startTime, expectedStartTime,  'AnimationPlayer.finish() should ' +
            'update player\'s start time');
        t.done();
    }), t.unreached_func('Current ready promise should not be rejected'));
}, 'AnimationPlayer.finish() updates player\'s start time to ' +
    'timeline time if playback rate < 0');

async_test(function(t) {
    var player = newAnimationPlayer(createDiv(t));
    var counter = 0;

    player.finished.then(t.step_func(function(plr) {
        counter++;
        assert_equals(plr, player, 'Finished promise should be resolved with player');
    }), t.unreached_func('Current finished promise should not be rejected'));

    player.ready.then(t.step_func(function() {
        player.finish();
        setTimeout(t.step_func(function(){
            assert_equals(counter, 1, 'Current finished promise should be resolved');
            t.done();
        }), ANIMATION_DURATION / 20);
    }), t.unreached_func('Current ready promise should not be rejected'));
}, 'Check that AnimationPlayer.finish() resolves curent finished promise with player');

test(function(t){
    var player = newAnimationPlayer(createDiv(t));
    var previousFinished = player.finished;
    player.finish();
    assert_not_equals(player.finished, previousFinished, 'AnimationPlayer.finished ' +
        'should be replaced with new Promise object');
}, 'Test AnimationPlayer.finish() set curent finished promise to a new (pending) Promise object');
</script>
</body>
