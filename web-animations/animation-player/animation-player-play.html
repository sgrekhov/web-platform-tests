<!DOCTYPE html>
<meta charset=utf-8>
<title>Animation player play() method test</title>
<meta name="assert" content="Unpauses the player and rewinds if it has finished playing">
<link rel="help" href="http://w3c.github.io/web-animations/#dom-animationplayer-play">
<link rel="author" title="Sergey G. Grekhov" href="mailto:sgrekhov@unipro.ru">
<script src="/resources/testharness.js"></script>
<script src="/resources/testharnessreport.js"></script>
<script src="../testcommon.js"></script>
<link rel="stylesheet" href="/resources/testharness.css">
<body>
<div id="log"></div>
<script>
var TIMEOUT = ANIMATION_DURATION / 20;

async_test(function(t) {
    var player = document.timeline.play(null);

    player.ready.then(t.step_func(function() {
        player.pause();
        player.play();

        assert_equals(player.playState, 'finished', 'AnimationPlayer play state ' +
            'should be finished');
        t.done();
    }), t.unreached_func('Current ready promise should not be rejected'));
}, 'Test that AnimationPlayer.play() unpauses the player even if player has no source content');

async_test(function(t) {
    var player = newAnimationPlayer(createDiv(t));
    var timesToTest = [
        -100,
        -1,
        0,
        1,
        100,
        ANIMATION_DURATION / 2,
        ANIMATION_DURATION - 100,
        ANIMATION_DURATION - 1,
        ANIMATION_DURATION,
        ANIMATION_DURATION + 1,
        ANIMATION_DURATION + 100];

    player.ready.then(t.step_func(function() {
        timesToTest.forEach(function(time) {
            player.currentTime = time;
            player.pause();
            player.play();

            assert_not_equals(player.playState, 'paused', 'AnimationPlayer should be ' +
                'unpaused for time ' + time);
        });
        t.done();
    }), t.unreached_func('Current ready promise should not be rejected'));
}, 'Test that AnimationPlayer.play() unpauses the player. Test different times');

async_test(function(t) {
    var player = newAnimationPlayer(createDiv(t));
    player.playbackRate = -1;
    var timesToTest = [
        -100,
        -1,
        0,
        1,
        100,
        ANIMATION_DURATION / 2,
        ANIMATION_DURATION - 100,
        ANIMATION_DURATION - 1,
        ANIMATION_DURATION,
        ANIMATION_DURATION + 1,
        ANIMATION_DURATION + 100];

    player.ready.then(t.step_func(function() {
        timesToTest.forEach(function(time) {
            player.currentTime = time;
            player.pause();
            player.play();

            assert_not_equals(player.playState, 'paused', 'AnimationPlayer should be ' +
                'unpaused for time ' + time);
        });
        t.done();
    }), t.unreached_func('Current ready promise should not be rejected'));
}, 'Test that AnimationPlayer.play() unpauses the player when playback rate < 0');

async_test(function(t) {
    var player = newAnimationPlayer(createDiv(this));

    player.ready.then(t.step_func(function() {
        // wait for TIMEOUT ms
        setTimeout(t.step_func(function() {
            player.pause();
            // wait for TIMEOUT ms
            setTimeout(t.step_func(function() {
                player.play();
                // wait for TIMEOUT ms
                setTimeout(t.step_func(function() {
                    assert_approx_equals(player.currentTime, 2 * TIMEOUT, TIME_EPSILON,
                        'After player is unpaused by AnimationPlayer.play() ' +
                        'current time should go on increasing');
                    t.done();
                }), TIMEOUT);
            }), TIMEOUT);
        }), TIMEOUT);
    }), t.unreached_func('Current ready promise should not be rejected'));
}, 'Test that after player is unpaused by AnimationPlayer.play() ' +
    'current time goes on increasing');

async_test(function(t) {
    var player = newAnimationPlayer(createDiv(this));
    player.playbackRate = -1;
    player.currentTime = ANIMATION_DURATION / 2;

    player.ready.then(t.step_func(function() {
        // wait for TIMEOUT ms
        setTimeout(t.step_func(function() {
            player.pause();
            // wait for TIMEOUT ms
            setTimeout(t.step_func(function() {
                player.play();
                // wait for TIMEOUT ms
                setTimeout(t.step_func(function() {
                    var expectedTime = ANIMATION_DURATION / 2 - 2 * TIMEOUT;
                    assert_approx_equals(player.currentTime, expectedTime, TIME_EPSILON,
                        'After player is unpaused by AnimationPlayer.play() ' +
                        'current time should go on decreasing');
                    t.done();
                }), TIMEOUT);
            }), TIMEOUT);
        }), TIMEOUT);
    }), t.unreached_func('Current ready promise should not be rejected'));
}, 'Test that after player is unpaused by AnimationPlayer.play() ' +
    'current time goes on decreasing if playback rate < 0');

async_test(function(t) {
    var player = newAnimationPlayer(createDiv(t));
    var times = [-1, player.source.computedTiming.endTime,
                 player.source.computedTiming.endTime + 1];

    player.ready.then(t.step_func(function() {
        times.forEach(function(time) {
            player.currentTime = time;
            player.play();

            assert_equals(player.currentTime, 0, 'AnimationPlayer.play() call should seek ' +
                'current time to zero for time ' + time);
        });
        t.done();
    }), t.unreached_func('Current ready promise should not be rejected'));
}, 'Test that AnimationPlayer.play() seeks current time to zero if current time < 0 or >= ' +
    'source content end');

async_test(function(t) {
    var player = newAnimationPlayer(createDiv(t));
    player.playbackRate = -1;
    var times = [-1, 0, player.source.computedTiming.endTime + 1];

    player.ready.then(t.step_func(function() {
        times.forEach(function(time) {
            player.currentTime = time;
            player.play();

            assert_equals(player.currentTime, player.source.computedTiming.endTime,
                'AnimationPlayer.play() call should seek current time to source content end ' +
                'for time ' + time);
        });
        t.done();
    }), t.unreached_func('Current ready promise should not be rejected'));
}, 'Test that AnimationPlayer.play() seeks current time to source content end ' +
    'if current time <= 0 or > source content end and playback rate < 0');

async_test(function(t) {
    var player = newAnimationPlayer(createDiv(t));

    player.ready.then(t.step_func(function() {
        player.currentTime = ANIMATION_DURATION / 2;
        player.play();

        assert_equals(player.currentTime, ANIMATION_DURATION / 2,
            'AnimationPlayer.play() call should not change current time');
        t.done();
    }), t.unreached_func('Current ready promise should not be rejected'));
}, 'Test that AnimationPlayer.play() does not change current time current time >= 0 and < ' +
    'source content end and playback rate > 0');

async_test(function(t) {
    var player = newAnimationPlayer(createDiv(t));
    player.playbackRate = -1;

    player.ready.then(t.step_func(function() {
        player.currentTime = ANIMATION_DURATION / 2;
        player.play();

        assert_equals(player.currentTime, ANIMATION_DURATION / 2,
            'AnimationPlayer.play() call should not change current time');
        t.done();
    }), t.unreached_func('Current ready promise should not be rejected'));
}, 'Test that AnimationPlayer.play() does not change current time current time > 0 and <= ' +
    'source content end and playback rate < 0');

async_test(function(t) {
    var player = newAnimationPlayer(createDiv(this));
    player.currentTime = player.source.computedTiming.endTime + 100;

    player.ready.then(t.step_func(function() {
        // wait for TIMEOUT ms
        setTimeout(t.step_func(function() {
            assert_equals(player.currentTime, player.source.computedTiming.endTime + 100,
                'currentTime value should not be changed');
            player.play();
            // wait for TIMEOUT ms
            setTimeout(t.step_func(function() {
                assert_approx_equals(player.currentTime, TIMEOUT, TIME_EPSILON,
                    'After AnimationPlayer.play() call ' +
                    'current time should go on increasing');
                t.done();
            }), TIMEOUT);
        }), TIMEOUT);
    }), t.unreached_func('Current ready promise should not be rejected'));
}, 'Test that if AnimationPlayer.play() is called when current time > source end time ' +
    'seek time is set to zero and starts increasing');

async_test(function(t) {
    var player = newAnimationPlayer(createDiv(this));
    player.playbackRate = -1;
    player.currentTime = -10;

    player.ready.then(t.step_func(function() {
        // wait for TIMEOUT ms
        setTimeout(t.step_func(function() {
            assert_equals(player.currentTime, -10, 'currentTime value should not be changed');
            player.play();
            // wait for TIMEOUT ms
            setTimeout(t.step_func(function() {
                assert_approx_equals(player.currentTime,
                    player.source.computedTiming.endTime - TIMEOUT, TIME_EPSILON,
                    'After AnimationPlayer.play() call' +
                    'current time should go on decreasing');
                t.done();
            }), TIMEOUT);
        }), TIMEOUT);
    }), t.unreached_func('Current ready promise should not be rejected'));
}, 'Test that if AnimationPlayer.play() is called when current time < 0 ' +
    'seek time is set to source end time and starts decreasing if playback rate < 0');

async_test(function(t) {
    var player = newAnimationPlayer(createDiv(t));

    player.ready.then(t.step_func(function() {
        player.currentTime = ANIMATION_DURATION / 2;
        player.playbackRate = 1.1;
        player.pause();
        setTimeout(t.step_func(function() {
            player.play();
            var expectedStartTime = player.timeline.currentTime -
                (ANIMATION_DURATION / 2) / player.playbackRate;
            assert_equals(player.startTime, expectedStartTime,
                'AnimationPlayer.play() should update start time when player is unpaused');
            t.done();
        }), TIMEOUT);
    }), t.unreached_func('Current ready promise should not be rejected'));
}, 'Test that AnimationPlayer.play() updates start time to ' +
    'timeline time - hold time / playback rate when player is unpaused');

async_test(function(t) {
    var player = newAnimationPlayer(createDiv(t));
    var resolveCounter = 0;

    player.ready.then(t.step_func(function() {
        player.currentTime = ANIMATION_DURATION / 2;
        player.pause();
        player.ready.then(function(plr) {
            resolveCounter++;
            assert_equals(plr, player, 'Current ready promise should be resolved with the player');
        }, t.unreached_func('Current ready promise should not be rejected'));
        player.play();

        setTimeout(t.step_func(function() {
            assert_equals(resolveCounter, 1, 'AnimationPlayer.play() should resolve ' +
                'current ready promise when player is unpaused');
            t.done();
        }), TIMEOUT);
    }), t.unreached_func('Current ready promise should not be rejected'));
}, 'Test that AnimationPlayer.play() resolves current ready promise with the player ' +
    'when player is unpaused');

async_test(function(t) {
    var source = new Animation(createDiv(t), KEYFRAMES, ANIMATION_DURATION);
    var player = new AnimationPlayer(source);
    player.playbackRate = 0;
    player.play();
    player.timeline = document.timeline;

    player.ready.then(t.step_func(function() {
        assert_equals(player.startTime, player.timeline.curentTime,
            'AnimationPlayer.play() should set start time to ready time if playback rate is 0');
        t.done();
    }), t.unreached_func('Current ready promise should not be rejected'));
}, 'Test that AnimationPlayer.play() sets start time to ready time if playback rate is 0');
</script>
</body>
