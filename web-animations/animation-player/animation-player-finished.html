<!DOCTYPE html>
<meta charset=utf-8>
<title>AnimationPlayer finished attribute tests</title>
<meta name="assert" content="Returns the current finished promise for this object">
<link rel="help" href="http://w3c.github.io/web-animations/#dom-animationplayer-finished">
<link rel="help" href="http://w3c.github.io/web-animations/#current-finished-promise">
<link rel="author" title="Sergey G. Grekhov" href="mailto:sgrekhov@unipro.ru">
<link rel="author" title="Aleksei Yu. Semenov" href="mailto:a.semenov@unipro.ru">
<script src="/resources/testharness.js"></script>
<script src="/resources/testharnessreport.js"></script>
<script src="../testcommon.js"></script>
<link rel="stylesheet" href="/resources/testharness.css">
<body>
<div id="log"></div>
<script>
var TIMEOUT = ANIMATION_DURATION / 20;

test(function() {
    var players = [
        new AnimationPlayer(),
        new AnimationPlayer(new Animation(createDiv(this), KEYFRAMES, ANIMATION_DURATION)),
        new AnimationPlayer(new Animation(createDiv(this), KEYFRAMES, ANIMATION_DURATION), document.timeline),
        document.timeline.play(new Animation(createDiv(this), KEYFRAMES, ANIMATION_DURATION))
    ];
    players.forEach(function(player, index) {
        assert_not_equals(player.finished, null, 'AnimationPlayer.finished should ' +
            'not be null for player '+index);
        assert_not_equals(player.finished.then, null, 'AnimationPlayer.finished.then should ' +
            'not be null for player '+index);
        assert_equals(typeof(player.finished.then), 'function', 'AnimationPlayer.finished.then should ' +
            'be a function for player '+index);
    });
}, 'Test AnimationPlayer.finished is a Promise object');

async_test(function(t) {
    var player = newAnimationPlayer(createDiv(t));
    var finishedCounter = 0;

    player.finished.then(t.step_func(function() {
        finishedCounter++;
    }), t.unreached_func('Current finished promise should not be rejected'));

    player.ready.then(t.step_func(function() {
        assert_equals(finishedCounter, 0, 'Curent finished promise should not be fulfilled');
        t.done();
    }), t.unreached_func('Current ready promise should not be rejected'));
}, 'Test that current finished promise is initially a pending Promise object');

async_test(function(t) {
    var player = newAnimationPlayer(createDiv(t));
    var finishedCounter = 0;

    player.finished.then(t.step_func(function() {
        finishedCounter++;
    }), t.unreached_func('Current finished promise should not be rejected'));

    player.ready.then(t.step_func(function() {
        setTimeout(t.step_func(function() {
            assert_equals(finishedCounter, 0, 'Curent finished promise should not be fulfilled');
            t.done();
        }), TIMEOUT);
    }), t.unreached_func('Current ready promise should not be rejected'));
}, 'Test that current finished promise is a pending Promise object ' +
    'while player is running');

async_test(function(t) {
    var player = newAnimationPlayer(createDiv(t));
    var finishedCounter = 0;

    player.finished.then(t.step_func(function() {
        finishedCounter++;
    }), t.unreached_func('Current finished promise should not be rejected'));

    player.ready.then(t.step_func(function() {
        player.currentTime = player.source.computedTiming.endTime - ( TIMEOUT / 2 );
        setTimeout(t.step_func(function() {
            assert_equals(finishedCounter, 1, 'Curent finished promise should not be fulfilled');
            t.done();
        }), TIMEOUT);
    }), t.unreached_func('Current ready promise should not be rejected'));
}, 'Test that current finished promise is fulfilled when player is finished');

async_test(function(t) {
    var player = newAnimationPlayer(createDiv(t));
    var finishedPromise = player.finished;
    var finishedCounter = 0;

    player.finished.then(t.step_func(function() {
        finishedCounter++;
    }), t.unreached_func('Current finished promise should not be rejected'));

    player.ready.then(t.step_func(function() {
        player.currentTime = player.source.computedTiming.endTime -  ( TIMEOUT / 2 );
        setTimeout(t.step_func(function() {
            assert_equals(finishedCounter, 1, 'Curent finished promise should be fulfilled');
            player.play();

            player.ready.then(t.step_func(function() {
                assert_not_equals(player.finished, finishedPromise, 'The current finished ' +
                    'promise should be replaced by new Promise object');
                t.done();
            }), t.unreached_func('Current ready promise should not be rejected'));
        }), TIMEOUT);
    }), t.unreached_func('Current ready promise should not be rejected'));
}, 'Test that current finished promise is replaced by new Promise object when player ' +
    'leaves the finished play state');

async_test(function(t) {
    var player = newAnimationPlayer(createDiv(t));
    player.playbackRate = -1;
    player.currentTime = TIMEOUT / 2;
    var finishedPromise = player.finished;
    var finishedCounter = 0;

    player.finished.then(t.step_func(function() {
        finishedCounter++;
    }), t.unreached_func('Current finished promise should not be rejected'));

    player.ready.then(t.step_func(function() {
        setTimeout(t.step_func(function() {
            assert_equals(finishedCounter, 1, 'Curent finished promise should be fulfilled');
            player.play();

            player.ready.then(t.step_func(function() {
                assert_not_equals(player.finished, finishedPromise, 'The current finished ' +
                    'promise should be replaced by new Promise object');
                t.done();
            }), t.unreached_func('Current ready promise should not be rejected'));
        }), TIMEOUT);
    }), t.unreached_func('Current ready promise should not be rejected'));
}, 'Test that current finished promise is replaced by new Promise object when player ' +
    'leaves the finished play state. Playback rate < 0');

async_test(function(t) {
    var player = newAnimationPlayer(createDiv(t));
    var finishedPromise = player.finished;
    var finishedCounter = 0;

    player.finished.then(t.step_func(function() {
        finishedCounter++;
    }), t.unreached_func('Current finished promise should not be rejected'));

    player.ready.then(t.step_func(function() {
        player.currentTime = player.source.computedTiming.endTime + 20;
        assert_equals(finishedCounter, 1, 'Curent finished promise should be fulfilled');
        assert_equals(player.finished, finishedPromise, 'Curent finished promise should be ' +
            'the same object');

        player.currentTime = player.source.computedTiming.endTime - 20;
        assert_not_equals(player.finished, finishedPromise, 'The current finished ' +
            'promise should be replaced by new Promise object');
        assert_equals(finishedCounter, 1, 'Previous finished promise should not be fulfilled');

        player.currentTime = player.source.computedTiming.endTime + 20;
        assert_equals(finishedCounter, 1, 'Previous finished promise should not be fulfilled');

        t.done();
    }), t.unreached_func('Current ready promise should not be rejected'));
}, 'Test that current finished promise is replaced by new Promise object when player ' +
    'leaves the finished play state. Finished state is reached by setting currentTime');

async_test(function(t) {
    var player = newAnimationPlayer(createDiv(t));
    var finishedPromise = player.finished;
    var finishedCounter = 0;

    player.finished.then(t.step_func(function() {
        finishedCounter++;
    }), t.unreached_func('Current finished promise should not be rejected'));

    player.ready.then(t.step_func(function() {
        player.finish();
        assert_equals(finishedCounter, 1, 'Curent finished promise should be fulfilled');
        assert_equals(player.finished, finishedPromise, 'Curent finished promise should be ' +
            'the same object');

        player.play();
        assert_not_equals(player.finished, finishedPromise, 'The current finished ' +
            'promise should be replaced by new Promise object');
        assert_equals(finishedCounter, 1, 'Previous finished promise should not be fulfilled');
        var finishedPromise2 = player.finished;

        player.finish();
        assert_equals(finishedCounter, 1, 'Previous finished promise should not be fulfilled');
        assert_equals(player.finished, finishedPromise2, 'Curent finished promise should be ' +
            'the same object');
        t.done();
    }), t.unreached_func('Current ready promise should not be rejected'));
}, 'Test that current finished promise is replaced by new Promise object when player ' +
    'leaves the finished play state and fulfilled when finished. Finished state is reached ' +
    'by calling AnimationPlayer.finish()');

async_test(function(t) {
    var player = newAnimationPlayer(createDiv(t));
    player.playbackRate = -1;
    player.currentTime = player.source.computedTiming.endTime;
    var finishedPromise = player.finished;
    var finishedCounter = 0;

    player.finished.then(t.step_func(function() {
        finishedCounter++;
    }), t.unreached_func('Current finished promise should not be rejected'));

    player.ready.then(t.step_func(function() {
        player.finish();
        assert_equals(finishedCounter, 1, 'Curent finished promise should be fulfilled');
        assert_equals(player.finished, finishedPromise, 'Curent finished promise should be ' +
            'the same object');

        player.play();
        assert_not_equals(player.finished, finishedPromise, 'The current finished ' +
            'promise should be replaced by new Promise object');
        assert_equals(finishedCounter, 1, 'Previous finished promise should not be fulfilled');
        var finishedPromise2 = player.finished;

        player.currentTime = 20;
        assert_equals(finishedCounter, 1, 'Previous finished promise should not be fulfilled');
        assert_equals(player.finished, finishedPromise2, 'Curent finished promise should be ' +
            'the same object');
        t.done();
    }), t.unreached_func('Current ready promise should not be rejected'));
}, 'Test that current finished promise is replaced by new Promise object when player ' +
    'leaves the finished play state and fulfilled when finished. Finished state reached ' +
    'by calling AnimationPlayer.finish() and playback rate < 0]');

async_test(function(t) {
    var player = newAnimationPlayer(createDiv(t));
    var finishedCounter = 0;

    player.finished.then(t.step_func(function() {
        finishedCounter++;
    }), t.unreached_func('Current finished promise should not be rejected'));

    player.ready.then(t.step_func(function() {
        player.currentTime = 100;
        assert_equals(finishedCounter, 0, 'Curent finished promise should not be fulfilled');

        player.currentTime = -100;
        assert_equals(finishedCounter, 0, 'Curent finished promise should not be fulfilled');
        t.done();
    }), t.unreached_func('Current ready promise should not be rejected'));
}, 'Test that current finished promise is not fulfilled if current time is set to negative value');

async_test(function(t) {
    var player = newAnimationPlayer(createDiv(t));
    player.playbackRate = -1;
    var finishedCounter = 0;

    player.finished.then(t.step_func(function() {
        finishedCounter++;
    }), t.unreached_func('Current finished promise should not be rejected'));

    player.ready.then(t.step_func(function() {
        player.currentTime = player.source.computedTiming.endTime - 100;
        assert_equals(finishedCounter, 0, 'Curent finished promise should not be fulfilled');

        player.currentTime = player.source.computedTiming.endTime + 100;
        assert_equals(finishedCounter, 0, 'Curent finished promise should not be fulfilled');
        t.done();
    }), t.unreached_func('Current ready promise should not be rejected'));
}, 'Test that current finished promise is not fulfilled if current time is set to value ' +
    'before end time and playback rate < 0');

async_test(function(t) {
    var player = newAnimationPlayer(createDiv(t));
    var finishedPromise = player.ready;
    var finishedCounter = 0;

    player.finished.then(t.step_func(function() {
        finishedCounter++;
    }), t.unreached_func('Current finished promise should not be rejected'));

    player.ready.then(t.step_func(function() {
        player.source = null;
        assert_equals(finishedCounter, 0, 'Curent finished promise should not be fulfilled');
        assert_not_equals(player.finished, finishedPromise, 'The current finished ' +
            'promise should be replaced by new Promise object');
        t.done();
    }), t.unreached_func('Current ready promise should not be rejected'));
}, 'Test that current finished promise is not fulfilled if source content is removed');

async_test(function(t) {
    var player = newAnimationPlayer(createDiv(t));
    var shortAnimation = new Animation(createDiv(t), KEYFRAMES, ANIMATION_DURATION / 4);
    var finishedPromise = player.ready;
    var finishedCounter = 0;

    player.finished.then(t.step_func(function() {
        finishedCounter++;
    }), t.unreached_func('Current finished promise should not be rejected'));

    player.ready.then(t.step_func(function() {
        player.currentTime = ANIMATION_DURATION / 2;
        player.source = shortAnimation;
        assert_equals(finishedCounter, 1, 'Curent finished promise should be fulfilled');
        assert_equals(player.finished, finishedPromise, 'The current finished ' +
            'promise should not be replaced by new Promise object');
        player.play();
        assert_not_equals(player.finished, finishedPromise, 'The current finished ' +
            'promise should be replaced by new Promise object');
        t.done();
    }), t.unreached_func('Current ready promise should not be rejected'));
}, 'Test that current finished promise is fulfilled if source content is replaced by shorter one');


async_test(function(t) {
    var player = new AnimationPlayer();
    var finishedCounter = 0;

    player.finished.then(t.step_func(function() {
        finishedCounter++;
    }), t.unreached_func('Current finished promise should not be rejected'));
    player.finish();

    setTimeout(t.step_func(function() {
        assert_equals(finishedCounter, 0, 'Curent finished promise should not be fulfilled');
        t.done();
    }), TIMEOUT);
}, 'Test that current finished promise is not fulfilled if player has no timeline ' +
    'associated and no source content even if AnimationPlayer.finish() is called');

async_test(function(t) {
    var player = newAnimationPlayer(createDiv(t));
    var finishedPromise = player.ready;
    var finishedCounter = 0;

    player.finished.then(t.step_func(function() {
        finishedCounter++;
    }), t.unreached_func('Current finished promise should not be rejected'));

    player.ready.then(t.step_func(function() {
        player.currentTime = ANIMATION_DURATION / 2;
        // Changing animation playback rate to 4 makes animation length 4 times shorter
        player.source.timing.playbackRate = 4;
        assert_equals(finishedCounter, 1, 'Curent finished promise should be fulfilled');
        assert_equals(player.finished, finishedPromise, 'The current finished ' +
            'promise should not be replaced by new Promise object');
        player.play();
        assert_not_equals(player.finished, finishedPromise, 'The current finished ' +
            'promise should be replaced by new Promise object');
        t.done();
    }), t.unreached_func('Current ready promise should not be rejected'));
}, 'Test that current finished promise is fulfilled if source content is shorted by ' +
    'changing playbackRate');
</script>
</body>
