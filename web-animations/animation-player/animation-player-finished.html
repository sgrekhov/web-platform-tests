<!DOCTYPE html>
<meta charset=utf-8>
<title>AnimationPlayer finished attribute tests</title>
<meta name="assert" content="Returns the current finished promise for this object">
<link rel="help" href="http://w3c.github.io/web-animations/#dom-animationplayer-finished">
<link rel="author" title="Sergey G. Grekhov" href="mailto:sgrekhov@unipro.ru">
<link rel="author" title="Aleksei Yu. Semenov" href="mailto:a.semenov@unipro.ru">
<script src="/resources/testharness.js"></script>
<script src="/resources/testharnessreport.js"></script>
<script src="../testcommon.js"></script>
<link rel="stylesheet" href="/resources/testharness.css">
<body>
<div id="log"></div>
<script>
async_test(function(t) {
    var player = newAnimationPlayer(createDiv(t));
    var finishedCounter = 0;

    player.finished.then(t.step_func(function() {
        finishedCounter++;
    }), t.unreached_func('Current finished promise should not be rejected'));

    player.ready.then(t.step_func(function() {
        assert_equals(finishedCounter, 0, 'Curent finished promise should not be fulfilled');
        t.done();
    }), t.unreached_func('Current ready promise should not be rejected'));
}, 'Test that current finished promise is initially a pending Promise object');

async_test(function(t) {
    var player = newAnimationPlayer(createDiv(t));
    var finishedCounter = 0;

    player.finished.then(t.step_func(function() {
        finishedCounter++;
    }), t.unreached_func('Current finished promise should not be rejected'));

    player.ready.then(t.step_func(function() {
        setTimeout(t.step_func(function() {
            assert_equals(finishedCounter, 0, 'Curent finished promise should not be fulfilled');
            t.done();
        }), 50);
    }), t.unreached_func('Current ready promise should not be rejected'));
}, 'Test that current finished promise is a pending Promise object and is not fulfilled ' +
    'while player is running');

async_test(function(t) {
    var player = newAnimationPlayer(createDiv(t));
    var finishedCounter = 0;

    player.finished.then(t.step_func(function() {
        finishedCounter++;
    }), t.unreached_func('Current finished promise should not be rejected'));

    player.ready.then(t.step_func(function() {
        player.currentTime = player.source.computedTiming.endTime - 20;
        setTimeout(t.step_func(function() {
            assert_equals(finishedCounter, 1, 'Curent finished promise should not be fulfilled');
            t.done();
        }), 50);
    }), t.unreached_func('Current ready promise should not be rejected'));
}, 'Test that current finished promise is fulfilled when player is finished');

async_test(function(t) {
    var player = newAnimationPlayer(createDiv(t));
    var finishedPromise = player.finished;
    var finishedCounter = 0;

    player.finished.then(t.step_func(function() {
        finishedCounter++;
    }), t.unreached_func('Current finished promise should not be rejected'));

    player.ready.then(t.step_func(function() {
        player.currentTime = player.source.computedTiming.endTime - 20;
        setTimeout(t.step_func(function() {
            assert_equals(finishedCounter, 1, 'Curent finished promise should be fulfilled');
            player.play();

            player.ready.then(t.step_func(function() {
                assert_not_equals(player.finished, finishedPromise, 'The current finished ' +
                    'promise should be replaced by new Promise object');
                t.done();
            }), t.unreached_func('Current ready promise should not be rejected'));
        }), 50);
    }), t.unreached_func('Current ready promise should not be rejected'));
}, 'Test that current finished promise is replaced by new Promise object when player ' +
    'leaves the finished play state');

async_test(function(t) {
    var player = newAnimationPlayer(createDiv(t));
    player.playbackRate = -1;
    player.currentTime = 20;
    var finishedPromise = player.finished;
    var finishedCounter = 0;

    player.finished.then(t.step_func(function() {
        finishedCounter++;
    }), t.unreached_func('Current finished promise should not be rejected'));

    player.ready.then(t.step_func(function() {
        setTimeout(t.step_func(function() {
            assert_equals(finishedCounter, 1, 'Curent finished promise should be fulfilled');
            player.play();

            player.ready.then(t.step_func(function() {
                assert_not_equals(player.finished, finishedPromise, 'The current finished ' +
                    'promise should be replaced by new Promise object');
                t.done();
            }), t.unreached_func('Current ready promise should not be rejected'));
        }), 50);
    }), t.unreached_func('Current ready promise should not be rejected'));
}, 'Test that current finished promise is replaced by new Promise object when player ' +
    'leaves the finished play state. Playback rate < 0');

async_test(function(t) {
    var player = newAnimationPlayer(createDiv(t));
    var finishedPromise = player.finished;
    var finishedCounter = 0;

    player.finished.then(t.step_func(function() {
        finishedCounter++;
    }), t.unreached_func('Current finished promise should not be rejected'));

    player.ready.then(t.step_func(function() {
        player.currentTime = player.source.computedTiming.endTime + 20;
        assert_equals(finishedCounter, 1, 'Curent finished promise should be fulfilled');
        assert_equals(player.finished, finishedPromise, 'Curent finished promise should be ' +
            'the same object');

        player.currentTime = player.source.computedTiming.endTime - 20;
        assert_not_equals(player.finished, finishedPromise, 'The current finished ' +
            'promise should be replaced by new Promise object');
        assert_equals(finishedCounter, 1, 'Previous finished promise should not be fulfilled');

        player.currentTime = player.source.computedTiming.endTime + 20;
        assert_equals(finishedCounter, 2, 'Previous finished promise should be fulfilled');

        t.done();
    }), t.unreached_func('Current ready promise should not be rejected'));
}, 'Test that current finished promise is replaced by new Promise object when player ' +
    'leaves the finished play state. Finished state reached by setting currentTime');

async_test(function(t) {
    var player = newAnimationPlayer(createDiv(t));
    var finishedPromise = player.finished;
    var finishedCounter = 0;

    player.finished.then(t.step_func(function() {
        finishedCounter++;
    }), t.unreached_func('Current finished promise should not be rejected'));

    player.ready.then(t.step_func(function() {
        player.finish();
        assert_equals(finishedCounter, 1, 'Curent finished promise should be fulfilled');
        assert_equals(player.finished, finishedPromise, 'Curent finished promise should be ' +
            'the same object');

        player.play();
        assert_not_equals(player.finished, finishedPromise, 'The current finished ' +
            'promise should be replaced by new Promise object');
        assert_equals(finishedCounter, 1, 'Previous finished promise should not be fulfilled');

        player.currentTime = player.source.computedTiming.endTime + 20;
        assert_equals(finishedCounter, 2, 'Previous finished promise should be fulfilled');
        t.done();
    }), t.unreached_func('Current ready promise should not be rejected'));
}, 'Test that current finished promise is replaced by new Promise object when player ' +
    'leaves the finished play state and fulfilled when finished. Finished state reached ' +
    'by calling AnimationPlayer.finish()');

// 11/11/2014 fihished here


test(function() {
    var player = newAnimationPlayer(createDiv(this));

    player.currentTime = ANIMATION_END_TIME - 100;
    assert_false(player.finished, 'The AnimationPlayer.finished attribute should be ' +
        'false if player time is less than source content end time');

    player.currentTime = ANIMATION_END_TIME + 100;
    assert_true(player.finished, 'The AnimationPlayer.finished attribute should be ' +
        'true if player time is greater than source content end time');

    player.currentTime = ANIMATION_END_TIME - 200;
    assert_false(player.finished, 'The AnimationPlayer.finished attribute should be ' +
        'false again if player time is less than source content end time');

    player.currentTime = ANIMATION_END_TIME + 200;
    assert_true(player.finished, 'The AnimationPlayer.finished attribute should be ' +
        'true again if player time is greater than source content end time');
}, 'Test the value of AnimationPlayer.finished attribute is set to true each time ' +
    'when player time is greater than source content end time');

test(function() {
    var player = newAnimationPlayer(createDiv(this));
    player.playbackRate = -1;

    player.currentTime = 100;
    assert_false(player.finished, 'The value of AnimationPlayer.finished attribute should be ' +
        'false if player time is less than source content end time');

    player.currentTime = -100;
    assert_true(player.finished, 'The value of AnimationPlayer.finished attribute should be ' +
        'true if player time is less than zero');

    player.currentTime = 200;
    assert_false(player.finished, 'The value of AnimationPlayer.finished attribute should be ' +
        'false again if player time is less than source content end time');

    player.currentTime = -200;
    assert_true(player.finished, 'The value of AnimationPlayer.finished attribute should be ' +
        'true again if player time is less than zero');
}, 'Test the value of AnimationPlayer.finished attribute is set to true each time ' +
    'when player currentTime is equal to or less than zero. Playback rate is -1');

test(function() {
    var player = newAnimationPlayer(createDiv(this));

    player.currentTime = 100;
    assert_false(player.finished, 'The value of AnimationPlayer.finished attribute should be ' +
        'false if player time is less than source content end time');

    player.currentTime = -100;
    assert_false(player.finished, 'The value of AnimationPlayer.finished attribute should be ' +
        'false if player time is before start time');
}, 'Test the value of AnimationPlayer.finished attribute is false if player time ' +
    'is set before start time');

test(function() {
    var player = newAnimationPlayer(createDiv(this));
    player.playbackRate = -1;

    player.currentTime = ANIMATION_END_TIME - 100;
    assert_false(player.finished, 'The value of AnimationPlayer.finished attribute should be ' +
        'false if player time is less than source content end time');

    player.currentTime = ANIMATION_END_TIME + 100;
    assert_false(player.finished, 'The value of AnimationPlayer.finished attribute should be ' +
        'false if player is finished');
}, 'Test the value of AnimationPlayer.finished attribute is false if player time ' +
    'is set after end time and player playback rate is -1');

async_test(function(t) {
    var player = newAnimationPlayer(createDiv(this));
    player.currentTime = ANIMATION_END_TIME - 100;
    setTimeout(function() {
        t.step(function () {
            assert_equals(player.currentTime, ANIMATION_END_TIME,
                'Player should reach source content end time');
            assert_true(player.finished, 'The value of AnimationPlayer.finished attribute ' +
                'should be set to true');
            t.done();
        });
    }, 150);
}, 'Test the AnimationPlayer.finished attribute is set to true ' +
    'if player reach end time of source content and playback rate is 1');

async_test(function(t) {
    var player = newAnimationPlayer(createDiv(this));
    player.currentTime = 100;
    player.playbackRate = -1;
    setTimeout(function() {
        t.step(function () {
            assert_equals(player.currentTime, 0,
                'Player should reach source content start time');
            assert_true(player.finished, 'The value of AnimationPlayer.finished attribute ' +
                'should be true');
            t.done();
        });
    }, 150);
}, 'Test the AnimationPlayer.finished attribute is set to true ' +
    'if player reach start time of source content and playback rate is -1');

test(function() {
    var player = newAnimationPlayer(createDiv(this));
    player.currentTime = ANIMATION_END_TIME + 100;
    assert_true(player.finished, 'The value of AnimationPlayer.finished attribute ' +
        'should be true');

    player.source = newLongAnimation(createDiv(this));

    assert_false(player.finished, 'The value of AnimationPlayer.finished attribute should be false');
}, 'Test AnimationPlayer.finished attribute is set to false if source content is changed ' +
    'and new source content end time is greater than player current time');

test(function() {
    var player = document.timeline.play(newLongAnimation(createDiv(this)));
    player.currentTime = ANIMATION_END_TIME + 100;
    assert_false(player.finished, 'The value of AnimationPlayer.finished attribute ' +
        'should be false');

    player.source = newAnimation(createDiv(this));

    assert_true(player.finished, 'The value of AnimationPlayer.finished attribute should be true');
}, 'Test AnimationPlayer.finished attribute is set to true if source content is changed ' +
    'and new source content end time is less than player current time');

test(function() {
    var player = newAnimationPlayer(createDiv(this));
    player.currentTime = ANIMATION_END_TIME / 2;
    player.source = null;

    assert_true(player.finished, 'The value of AnimationPlayer.finished attribute should be true');
}, 'Test AnimationPlayer.finished attribute is set to true if source content is removed');

test(function() {
    var player = document.timeline.play(null);
    player.currentTime = 100;
    assert_true(player.finished, 'The value of AnimationPlayer.finished attribute ' +
        'should be true');

    player.source = newAnimation(createDiv(this));

    assert_false(player.finished, 'The value of AnimationPlayer.finished attribute should be false');
}, 'Test AnimationPlayer.finished attribute is set to false if source content is set ' +
    'and new source content end time is greater than player current time');

test(function() {
    var player = document.timeline.play(null);
    player.currentTime = ANIMATION_END_TIME + 100;
    player.source = newAnimation(createDiv(this));

    assert_true(player.finished, 'The value of AnimationPlayer.finished attribute should be true');
}, 'Test AnimationPlayer.finished attribute is set to true if source content is set ' +
    'and new source content end time is greater than player current time');

test(function() {
    var player = document.timeline.play(null);
    player.currentTime = -100;
    player.source = newAnimation(createDiv(this));

    assert_false(player.finished, 'The value of AnimationPlayer.finished attribute should be false');
}, 'Test AnimationPlayer.finished attribute is set to false if source content is set ' +
    'and player current time is less than new source content start time');

test(function() {
    var player = document.timeline.play(null);
    player.currentTime = -100;
    player.playbackRate = -1;
    player.source = newAnimation(createDiv(this));

    assert_true(player.finished, 'The AnimationPlayer.finished attribute should be false');
}, 'Test AnimationPlayer.finished attribute is set to false if source content is set ' +
    'and player current time is less than new source content start time and playback rate is negative');

test(function() {
    var animation = newAnimation(createDiv(this));
    var player = document.timeline.play(animation);
    player.currentTime = 700;

    // Changing animation playback rate to 2 makes animation length 2 times shorter
    animation.timing.playbackRate = 2;

    assert_true(player.finished, 'The value of AnimationPlayer.finished attribute should be true');
}, 'Test the AnimationPlayer.finished is set to true if source content end time is changed to be '+
    'less than player current time');

test(function() {
    var animation = newAnimation(createDiv(this));
    var player = document.timeline.play(animation);
    player.currentTime = ANIMATION_END_TIME + 100;

    // Changing animation playback rate to 2 makes animation length 2 times longer
    animation.timing.playbackRate = 0.5;

    assert_false(player.finished, 'The value of AnimationPlayer.finished attribute should be false');
}, 'Test the AnimationPlayer.finished is set to false if source content end time is changed to be '+
    'greater than player current time');
</script>
</body>
